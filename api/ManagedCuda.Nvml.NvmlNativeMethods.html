<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class NvmlNativeMethods
   | ManagedCuda.NETStandard </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class NvmlNativeMethods
   | ManagedCuda.NETStandard ">
    <meta name="generator" content="docfx 2.35.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="ManagedCuda.Nvml.NvmlNativeMethods">
  
  
  <h1 id="ManagedCuda_Nvml_NvmlNativeMethods" data-uid="ManagedCuda.Nvml.NvmlNativeMethods" class="text-break">Class NvmlNativeMethods
  </h1>
  <div class="markdown level0 summary"></div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><span class="xref">NvmlNativeMethods</span></div>
  </div>
  <div class="inheritedMembers">
    <h5>Inherited Members</h5>
    <div>
      <span class="xref">System.Object.Equals(System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.GetHashCode()</span>
    </div>
    <div>
      <span class="xref">System.Object.GetType()</span>
    </div>
    <div>
      <span class="xref">System.Object.MemberwiseClone()</span>
    </div>
    <div>
      <span class="xref">System.Object.ReferenceEquals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.ToString()</span>
    </div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="ManagedCuda.Nvml.html">ManagedCuda.Nvml</a></h6>
  <h6><strong>Assembly</strong>: ManagedNvml.dll</h6>
  <h5 id="ManagedCuda_Nvml_NvmlNativeMethods_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static class NvmlNativeMethods</code></pre>
  </div>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceClearAccountingPids_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceClearAccountingPids*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceClearAccountingPids_ManagedCuda_Nvml_nvmlDevice_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceClearAccountingPids(ManagedCuda.Nvml.nvmlDevice)">nvmlDeviceClearAccountingPids(nvmlDevice)</h4>
  <div class="markdown level1 summary"><p>Clears accounting information about all processes that have already terminated.
For Kepler or newer fully supported devices.
Requires root/admin permissions.
See \ref nvmlDeviceGetAccountingMode
See \ref nvmlDeviceGetAccountingStats
See \ref nvmlDeviceSetAccountingMode</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceClearAccountingPids(nvmlDevice device)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if accounting information has been cleared</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device are invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceClearCpuAffinity_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceClearCpuAffinity*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceClearCpuAffinity_ManagedCuda_Nvml_nvmlDevice_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceClearCpuAffinity(ManagedCuda.Nvml.nvmlDevice)">nvmlDeviceClearCpuAffinity(nvmlDevice)</h4>
  <div class="markdown level1 summary"><p>Clear all affinity bindings for the calling thread.  Note, this is a change as of version
8.0 as older versions cleared the affinity for a calling process and all children.
For Kepler or newer fully supported devices.
Supported on Linux only.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceClearCpuAffinity(nvmlDevice device)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if the calling process has been successfully unbound</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceClearEccErrorCounts_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceClearEccErrorCounts*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceClearEccErrorCounts_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEccCounterType_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceClearEccErrorCounts(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEccCounterType)">nvmlDeviceClearEccErrorCounts(nvmlDevice, nvmlEccCounterType)</h4>
  <div class="markdown level1 summary"><p>Clear the ECC error and other memory error counts for the device.
For Kepler or newer fully supported devices.
Only applicable to devices with ECC.
Requires \a NVML_INFOROM_ECC version 2.0 or higher to clear aggregate location-based ECC counts.
Requires \a NVML_INFOROM_ECC version 1.0 or higher to clear all other ECC counts.
Requires root/admin permissions.
Requires ECC Mode to be enabled.
Sets all of the specified ECC counters to 0, including both detailed and total counts.
This operation takes effect immediately.
See \ref nvmlMemoryErrorType for details on available counter types.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceClearEccErrorCounts(nvmlDevice device, nvmlEccCounterType counterType)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEccCounterType.html">nvmlEccCounterType</a></td>
        <td><span class="parametername">counterType</span></td>
        <td><p>Flag that indicates which type of errors should be cleared.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if the error counts were cleared
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a counterType is invalid
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_NO_PERMISSION     if the user doesn&amp;apos;t have permission to perform this operation
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see</p>
<ul>
<li>nvmlDeviceGetDetailedEccErrors()</li>
<li>nvmlDeviceGetTotalEccErrors()</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceDiscoverGpus_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceDiscoverGpus*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceDiscoverGpus_ManagedCuda_Nvml_nvmlPciInfo__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceDiscoverGpus(ManagedCuda.Nvml.nvmlPciInfo@)">nvmlDeviceDiscoverGpus(ref nvmlPciInfo)</h4>
  <div class="markdown level1 summary"><p>Request the OS and the NVIDIA kernel driver to rediscover a portion of the PCI subsystem looking for GPUs that
were previously removed. The portion of the PCI tree can be narrowed by specifying a domain, bus, and device.<br>
If all are zeroes then the entire PCI tree will be searched.  Please note that for long-running NVML processes
the enumeration will change based on how many GPUs are discovered and where they are inserted in bus order.
In addition, all newly discovered GPUs will be initialized and their ECC scrubbed which may take several seconds
per GPU. Also, all device handles are no longer guaranteed to be valid post discovery.
Must be run as administrator.
For Linux only.</p>
<p>For newer than Maxwell fully supported devices.
Some Kepler devices supported.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceDiscoverGpus(ref nvmlPciInfo spciInfo)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlPciInfo.html">nvmlPciInfo</a></td>
        <td><span class="parametername">spciInfo</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if counters were successfully reset</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a pciInfo is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the operating system does not support this feature</li>
<li>\ref NVML_ERROR_OPERATING_SYSTEM  if the operating system is denying this feature</li>
<li>\ref NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceFreezeNvLinkUtilizationCounter_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceFreezeNvLinkUtilizationCounter*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceFreezeNvLinkUtilizationCounter_ManagedCuda_Nvml_nvmlDevice_System_UInt32_System_UInt32_ManagedCuda_Nvml_nvmlEnableState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceFreezeNvLinkUtilizationCounter(ManagedCuda.Nvml.nvmlDevice,System.UInt32,System.UInt32,ManagedCuda.Nvml.nvmlEnableState)">nvmlDeviceFreezeNvLinkUtilizationCounter(nvmlDevice, UInt32, UInt32, nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Freeze the NVLINK utilization counters
Both the receive and transmit counters are operated on by this function
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceFreezeNvLinkUtilizationCounter(nvmlDevice device, uint link, uint counter, nvmlEnableState freeze)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">link</span></td>
        <td><p>Specifies the NvLink link to be queried</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">counter</span></td>
        <td><p>Specifies the counter that should be frozen (0 or 1).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">freeze</span></td>
        <td><p>NVML_FEATURE_ENABLED = freeze the receive and transmit counters</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if counters were successfully frozen or unfrozen</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, \a counter, or \a freeze is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAccountingBufferSize_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAccountingBufferSize*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAccountingBufferSize_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAccountingBufferSize(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetAccountingBufferSize(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Returns the number of processes that the circular buffer with accounting pids can hold.
For Kepler or newer fully supported devices.
This is the maximum number of processes that accounting information will be stored for before information
about oldest processes will get overwritten by information about new processes.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetAccountingBufferSize(nvmlDevice device, ref uint bufferSize)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">bufferSize</span></td>
        <td><p>Reference in which to provide the size (in number of elements)</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if buffer size was successfully retrieved
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a bufferSize is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn&amp;apos;t support this feature or accounting mode is disabled
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetAccountingStats
@see nvmlDeviceGetAccountingPids</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAccountingMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAccountingMode*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAccountingMode_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAccountingMode(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState@)">nvmlDeviceGetAccountingMode(nvmlDevice, ref nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Queries the state of per process accounting mode.
For Kepler or newer fully supported devices.
See \ref nvmlDeviceGetAccountingStats for more details.
See \ref nvmlDeviceSetAccountingMode</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetAccountingMode(nvmlDevice device, ref nvmlEnableState mode)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">mode</span></td>
        <td><p>Reference in which to return the current accounting mode</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if the mode has been successfully retrieved</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode are NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAccountingPids_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAccountingPids*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAccountingPids_ManagedCuda_Nvml_nvmlDevice_System_UInt32__System_UInt32___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAccountingPids(ManagedCuda.Nvml.nvmlDevice,System.UInt32@,System.UInt32[])">nvmlDeviceGetAccountingPids(nvmlDevice, ref UInt32, UInt32[])</h4>
  <div class="markdown level1 summary"><p>Queries list of processes that can be queried for accounting stats. The list of processes returned
can be in running or terminated state.
For Kepler or newer fully supported devices.
To just query the number of processes ready to be queried, call this function with *count = 0 and
pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty.</p>
<p>For more details see \ref nvmlDeviceGetAccountingStats.
@note In case of PID collision some processes might not be accessible before the circular buffer is full.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetAccountingPids(nvmlDevice device, ref uint count, uint[] pids)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>Reference in which to provide the \a pids array size, and</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span>[]</td>
        <td><span class="parametername">pids</span></td>
        <td><p>Reference in which to return list of process ids</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if pids were successfully retrieved
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a count is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn&amp;apos;t support this feature or accounting mode is disabled
- \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set to
                                        expected value)
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetAccountingBufferSize</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAccountingStats_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAccountingStats*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAccountingStats_ManagedCuda_Nvml_nvmlDevice_System_UInt32_ManagedCuda_Nvml_nvmlAccountingStats__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAccountingStats(ManagedCuda.Nvml.nvmlDevice,System.UInt32,ManagedCuda.Nvml.nvmlAccountingStats@)">nvmlDeviceGetAccountingStats(nvmlDevice, UInt32, ref nvmlAccountingStats)</h4>
  <div class="markdown level1 summary"><p>Queries process's accounting stats.
For Kepler or newer fully supported devices.</p>
<p>Accounting stats capture GPU utilization and other statistics across the lifetime of a process.
Accounting stats can be queried during life time of the process and after its termination.
The time field in \ref nvmlAccountingStats is reported as 0 during the lifetime of the process and
updated to actual running time after its termination.
Accounting stats are kept in a circular buffer, newly created processes overwrite information about old
processes.
See \ref nvmlAccountingStats for description of each returned metric.
List of processes that can be queried can be retrieved from \ref nvmlDeviceGetAccountingPids.
@note Accounting Mode needs to be on. See \ref nvmlDeviceGetAccountingMode.
@note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be
queried since they don't contribute to GPU utilization.
@note In case of pid collision stats of only the latest process (that terminated last) will be reported
@warning On Kepler devices per process statistics are accurate only if there's one process running on a GPU.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetAccountingStats(nvmlDevice device, uint pid, ref nvmlAccountingStats stats)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">pid</span></td>
        <td><p>Process Id of the target process to query stats for</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlAccountingStats.html">nvmlAccountingStats</a></td>
        <td><span class="parametername">stats</span></td>
        <td><p>Reference in which to return the process's accounting stats</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if stats have been successfully retrieved
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a stats are NULL
- \ref NVML_ERROR_NOT_FOUND         if process stats were not found
- \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn&amp;apos;t support this feature or accounting mode is disabled
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetAccountingBufferSize</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAPIRestriction_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAPIRestriction*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAPIRestriction_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlRestrictedAPI_ManagedCuda_Nvml_nvmlEnableState__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAPIRestriction(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlRestrictedAPI,ManagedCuda.Nvml.nvmlEnableState@)">nvmlDeviceGetAPIRestriction(nvmlDevice, nvmlRestrictedAPI, ref nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Retrieves the root/admin permissions on the target API. See \a nvmlRestrictedAPI for the list of supported APIs.
If an API is restricted only root users can call that API. See \a nvmlDeviceSetAPIRestriction to change current permissions.
For all fully supported products.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetAPIRestriction(nvmlDevice device, nvmlRestrictedAPI apiType, ref nvmlEnableState isRestricted)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlRestrictedAPI.html">nvmlRestrictedAPI</a></td>
        <td><span class="parametername">apiType</span></td>
        <td><p>Target API type for this operation</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">isRestricted</span></td>
        <td><p>Reference in which to return the current restriction</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a isRestricted has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a apiType incorrect or \a isRestricted is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device or the device does not support
                                        the feature that is being queried (E.G. Enabling/disabling auto boosted clocks is
                                        not supported by the device)
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlRestrictedAPI</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetApplicationsClock_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetApplicationsClock*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetApplicationsClock_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlClockType_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetApplicationsClock(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlClockType,System.UInt32@)">nvmlDeviceGetApplicationsClock(nvmlDevice, nvmlClockType, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current setting of a clock that applications will use unless an overspec situation occurs.
Can be changed using \ref nvmlDeviceSetApplicationsClocks.
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetApplicationsClock(nvmlDevice device, nvmlClockType clockType, ref uint clockMHz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlClockType.html">nvmlClockType</a></td>
        <td><span class="parametername">clockType</span></td>
        <td><p>Identify which clock domain to query</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">clockMHz</span></td>
        <td><p>Reference in which to return the clock in MHz</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a clockMHz has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAutoBoostedClocksEnabled_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAutoBoostedClocksEnabled*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetAutoBoostedClocksEnabled_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState__ManagedCuda_Nvml_nvmlEnableState__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetAutoBoostedClocksEnabled(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState@,ManagedCuda.Nvml.nvmlEnableState@)">nvmlDeviceGetAutoBoostedClocksEnabled(nvmlDevice, ref nvmlEnableState, ref nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Retrieve the current state of auto boosted clocks on a device and store it in \a isEnabled
For Kepler or newer fully supported devices.
Auto boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
to maximize performance as thermal limits allow.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetAutoBoostedClocksEnabled(nvmlDevice device, ref nvmlEnableState isEnabled, ref nvmlEnableState defaultIsEnabled)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">isEnabled</span></td>
        <td><p>Where to store the current state of auto boosted clocks of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">defaultIsEnabled</span></td>
        <td><p>Where to store the default auto boosted clocks behavior of the target device that the device will</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 If \a isEnabled has been been set with the auto boosted clocks state of \a device</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isEnabled is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support auto boosted clocks</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetBAR1MemoryInfo_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetBAR1MemoryInfo*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetBAR1MemoryInfo_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlBAR1Memory__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetBAR1MemoryInfo(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlBAR1Memory@)">nvmlDeviceGetBAR1MemoryInfo(nvmlDevice, ref nvmlBAR1Memory)</h4>
  <div class="markdown level1 summary"><p>Gets Total, Available and Used size of BAR1 memory.</p>
<p>BAR1 is used to map the FB (device memory) so that it can be directly accessed by the CPU or by 3rd party
devices (peer-to-peer on the PCIE bus).</p>
<p>For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetBAR1MemoryInfo(nvmlDevice device, ref nvmlBAR1Memory bar1Memory)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlBAR1Memory.html">nvmlBAR1Memory</a></td>
        <td><span class="parametername">bar1Memory</span></td>
        <td><p>Reference in which BAR1 memory</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if BAR1 memory is successfully retrieved</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a bar1Memory is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetBoardId_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetBoardId*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetBoardId_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetBoardId(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetBoardId(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the device boardId from 0-N.
Devices with the same boardId indicate GPUs connected to the same PLX.  Use in conjunction with
\ref nvmlDeviceGetMultiGpuBoard() to decide if they are on the same board as well.
The boardId returned is a unique ID for the current configuration.  Uniqueness and ordering across
reboots and system configurations is not guaranteed (i.e. if a Tesla K40c returns 0x100 and
the two GPUs on a Tesla K10 in the same system returns 0x200 it is not guaranteed they will
always return those values but they will always be different from each other).</p>
<p>For Fermi or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetBoardId(nvmlDevice device, ref uint boardId)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">boardId</span></td>
        <td><p>Reference in which to return the device's board ID</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a boardId has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a boardId is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  <span class="small pull-right mobile-hide">
    <span class="divider">|</span>
    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetBoardPartNumber_ManagedCuda_Nvml_nvmlDevice_System_String__.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetBoardPartNumber(ManagedCuda.Nvml.nvmlDevice%2CSystem.String%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
  </span>
  <span class="small pull-right mobile-hide">
    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L800">View Source</a>
  </span>
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetBoardPartNumber_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetBoardPartNumber*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetBoardPartNumber_ManagedCuda_Nvml_nvmlDevice_System_String__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetBoardPartNumber(ManagedCuda.Nvml.nvmlDevice,System.String@)">nvmlDeviceGetBoardPartNumber(nvmlDevice, out String)</h4>
  <div class="markdown level1 summary"><p>Retrieves the the device board part number which is programmed into the board's InfoROM
For all products.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetBoardPartNumber(nvmlDevice device, out string partNumber)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>Identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">partNumber</span></td>
        <td><p>Reference to the buffer to return</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                  if \a partNumber has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED      if the needed VBIOS fields have not been filled</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid or \a serial is NULL</li>
<li>\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN            on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetBrand_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetBrand*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetBrand_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlBrandType__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetBrand(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlBrandType@)">nvmlDeviceGetBrand(nvmlDevice, ref nvmlBrandType)</h4>
  <div class="markdown level1 summary"><p>Retrieves the brand of this device.
For all products.
The type is a member of \ref nvmlBrandType defined above.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetBrand(nvmlDevice device, ref nvmlBrandType type)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlBrandType.html">nvmlBrandType</a></td>
        <td><span class="parametername">type</span></td>
        <td><p>Reference in which to return the product brand type</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a name has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a type is NULL</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetBridgeChipInfo_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetBridgeChipInfo*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetBridgeChipInfo_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlBridgeChipHierarchy__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetBridgeChipInfo(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlBridgeChipHierarchy@)">nvmlDeviceGetBridgeChipInfo(nvmlDevice, ref nvmlBridgeChipHierarchy)</h4>
  <div class="markdown level1 summary"><p>Get Bridge Chip Information for all the bridge chips on the board.</p>
<p>For all fully supported products.
Only applicable to multi-GPU products.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetBridgeChipInfo(nvmlDevice device, ref nvmlBridgeChipHierarchy bridgeHierarchy)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlBridgeChipHierarchy.html">nvmlBridgeChipHierarchy</a></td>
        <td><span class="parametername">bridgeHierarchy</span></td>
        <td><p>Reference to the returned bridge chip Hierarchy</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if bridge chip exists</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a bridgeInfo is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if bridge chip not supported on the device</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetClock_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetClock*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetClock_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlClockType_ManagedCuda_Nvml_nvmlClockId_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetClock(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlClockType,ManagedCuda.Nvml.nvmlClockId,System.UInt32@)">nvmlDeviceGetClock(nvmlDevice, nvmlClockType, nvmlClockId, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the clock speed for the clock specified by the clock type and clock ID.
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetClock(nvmlDevice device, nvmlClockType clockType, nvmlClockId clockId, ref uint clockMHz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlClockType.html">nvmlClockType</a></td>
        <td><span class="parametername">clockType</span></td>
        <td><p>Identify which clock domain to query</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlClockId.html">nvmlClockId</a></td>
        <td><span class="parametername">clockId</span></td>
        <td><p>Identify which clock in the domain to query</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">clockMHz</span></td>
        <td><p>Reference in which to return the clock in MHz</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a clockMHz has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetClockInfo_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetClockInfo*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetClockInfo_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlClockType_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetClockInfo(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlClockType,System.UInt32@)">nvmlDeviceGetClockInfo(nvmlDevice, nvmlClockType, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current clock speeds for the device.
For Fermi or newer fully supported devices.
See \ref nvmlClockType for details on available clock information.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetClockInfo(nvmlDevice device, nvmlClockType type, ref uint clock)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlClockType.html">nvmlClockType</a></td>
        <td><span class="parametername">type</span></td>
        <td><p>Identify which clock domain to query</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">clock</span></td>
        <td><p>Reference in which to return the clock speed in MHz</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a clock has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetComputeMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetComputeMode*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetComputeMode_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlComputeMode__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetComputeMode(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlComputeMode@)">nvmlDeviceGetComputeMode(nvmlDevice, ref nvmlComputeMode)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current compute mode for the device.
For all products.
See \ref nvmlComputeMode for details on allowed compute modes.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetComputeMode(nvmlDevice device, ref nvmlComputeMode mode)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlComputeMode.html">nvmlComputeMode</a></td>
        <td><span class="parametername">mode</span></td>
        <td><p>Reference in which to return the current compute mode</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a mode has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceSetComputeMode()</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetComputeRunningProcesses_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetComputeRunningProcesses*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetComputeRunningProcesses_ManagedCuda_Nvml_nvmlDevice_System_UInt32__ManagedCuda_Nvml_nvmlProcessInfo___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetComputeRunningProcesses(ManagedCuda.Nvml.nvmlDevice,System.UInt32@,ManagedCuda.Nvml.nvmlProcessInfo[])">nvmlDeviceGetComputeRunningProcesses(nvmlDevice, ref UInt32, nvmlProcessInfo[])</h4>
  <div class="markdown level1 summary"><p>Get information about processes with a compute context on a device
For Fermi or newer fully supported devices.
This function returns information only about compute running processes (e.g. CUDA application which have
active context). Any graphics applications (e.g. using OpenGL, DirectX) won't be listed by this function.
To query the current number of running compute processes, call this function with *infoCount = 0. The
return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call
\a infos is allowed to be NULL.
The usedGpuMemory field returned is all of the memory used by the application.
Keep in mind that information returned by this call is dynamic and the number of elements might change in
time. Allocate more space for \a infos table in case new compute processes are spawned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetComputeRunningProcesses(nvmlDevice device, ref uint infoCount, nvmlProcessInfo[] infos)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">infoCount</span></td>
        <td><p>Reference in which to provide the \a infos array size, and</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlProcessInfo.html">nvmlProcessInfo</a>[]</td>
        <td><span class="parametername">infos</span></td>
        <td><p>Reference in which to return the process information</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a infoCount and \a infos have been populated
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INSUFFICIENT_SIZE if \a infoCount indicates that the \a infos array is too small
                                    \a infoCount will contain minimal amount of space necessary for
                                    the call to complete
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, either of \a infoCount or \a infos is NULL
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see \ref nvmlSystemGetProcessName</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetCount_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetCount*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetCount_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetCount(System.UInt32@)">nvmlDeviceGetCount(ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the number of compute devices in the system. A compute device is a single GPU.</p>
<p>For all products.
Note: New nvmlDeviceGetCount_v2 (default in NVML 5.319) returns count of all devices in the system
even if nvmlDeviceGetHandleByIndex_v2 returns NVML_ERROR_NO_PERMISSION for such device.
Update your code to handle this error, or use NVML 4.304 or older nvml header file.
For backward binary compatibility reasons _v1 version of the API is still present in the shared
library.
Old _v1 version of nvmlDeviceGetCount doesn't count devices that NVML has no permission to talk to.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetCount(ref uint deviceCount)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">deviceCount</span></td>
        <td><p>Reference in which to return the number of accessible devices</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a deviceCount has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a deviceCount is NULL</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetCpuAffinity_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetCpuAffinity*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetCpuAffinity_ManagedCuda_Nvml_nvmlDevice_System_UInt32_System_UInt64___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetCpuAffinity(ManagedCuda.Nvml.nvmlDevice,System.UInt32,System.UInt64[])">nvmlDeviceGetCpuAffinity(nvmlDevice, UInt32, UInt64[])</h4>
  <div class="markdown level1 summary"><p>Retrieves an array of uints (sized to cpuSetSize) of bitmasks with the ideal CPU affinity for the device
For example, if processors 0, 1, 32, and 33 are ideal for the device and cpuSetSize == 2,
result[0] = 0x3, result[1] = 0x3
For Kepler or newer fully supported devices.
Supported on Linux only.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetCpuAffinity(nvmlDevice device, uint cpuSetSize, ulong[] cpuSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">cpuSetSize</span></td>
        <td><p>The size of the cpuSet array that is safe to access</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span>[]</td>
        <td><span class="parametername">cpuSet</span></td>
        <td><p>Array reference in which to return a bitmask of CPUs, 64 CPUs per</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a cpuAffinity has been filled</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, cpuSetSize == 0, or cpuSet is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetCurrentClocksThrottleReasons_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetCurrentClocksThrottleReasons*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetCurrentClocksThrottleReasons_ManagedCuda_Nvml_nvmlDevice_System_UInt64__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetCurrentClocksThrottleReasons(ManagedCuda.Nvml.nvmlDevice,System.UInt64@)">nvmlDeviceGetCurrentClocksThrottleReasons(nvmlDevice, ref UInt64)</h4>
  <div class="markdown level1 summary"><p>Retrieves current clocks throttling reasons.
For all fully supported products.
\note More than one bit can be enabled at the same time. Multiple reasons can be affecting clocks at once.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetCurrentClocksThrottleReasons(nvmlDevice device, ref ulong clocksThrottleReasons)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span></td>
        <td><span class="parametername">clocksThrottleReasons</span></td>
        <td><p>Reference in which to return bitmask of active clocks throttle</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a clocksThrottleReasons has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clocksThrottleReasons is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlClocksThrottleReasons
@see nvmlDeviceGetSupportedClocksThrottleReasons</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetCurrPcieLinkGeneration_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetCurrPcieLinkGeneration*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetCurrPcieLinkGeneration_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetCurrPcieLinkGeneration(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetCurrPcieLinkGeneration(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current PCIe link generation</p>
<p>For Fermi or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetCurrPcieLinkGeneration(nvmlDevice device, ref uint currLinkGen)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">currLinkGen</span></td>
        <td><p>Reference in which to return the current PCIe link generation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a currLinkGen has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a currLinkGen is null</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetCurrPcieLinkWidth_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetCurrPcieLinkWidth*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetCurrPcieLinkWidth_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetCurrPcieLinkWidth(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetCurrPcieLinkWidth(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current PCIe link width</p>
<p>For Fermi or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetCurrPcieLinkWidth(nvmlDevice device, ref uint currLinkWidth)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">currLinkWidth</span></td>
        <td><p>Reference in which to return the current PCIe link generation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a currLinkWidth has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a currLinkWidth is null</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetDecoderUtilization_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetDecoderUtilization*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetDecoderUtilization_ManagedCuda_Nvml_nvmlDevice_System_UInt32__System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetDecoderUtilization(ManagedCuda.Nvml.nvmlDevice,System.UInt32@,System.UInt32@)">nvmlDeviceGetDecoderUtilization(nvmlDevice, ref UInt32, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current utilization and sampling size in microseconds for the Decoder
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetDecoderUtilization(nvmlDevice device, ref uint utilization, ref uint samplingPeriodUs)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">utilization</span></td>
        <td><p>Reference to an uint for decoder utilization info</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">samplingPeriodUs</span></td>
        <td><p>Reference to an uint for the sampling period in US</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a utilization has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetDefaultApplicationsClock_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetDefaultApplicationsClock*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetDefaultApplicationsClock_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlClockType_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetDefaultApplicationsClock(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlClockType,System.UInt32@)">nvmlDeviceGetDefaultApplicationsClock(nvmlDevice, nvmlClockType, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the default applications clock that GPU boots with or
defaults to after \ref nvmlDeviceResetApplicationsClocks call.
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetDefaultApplicationsClock(nvmlDevice device, nvmlClockType clockType, ref uint clockMHz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlClockType.html">nvmlClockType</a></td>
        <td><span class="parametername">clockType</span></td>
        <td><p>Identify which clock domain to query</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">clockMHz</span></td>
        <td><p>Reference in which to return the default clock in MHz</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a clockMHz has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>\see nvmlDeviceGetApplicationsClock</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetDisplayActive_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetDisplayActive*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetDisplayActive_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetDisplayActive(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState@)">nvmlDeviceGetDisplayActive(nvmlDevice, ref nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Retrieves the display active state for the device.
For all products.
This method indicates whether a display is initialized on the device.
For example whether X Server is attached to this device and has allocated memory for the screen.
Display can be active even when no monitor is physically attached.
See \ref nvmlEnableState for details on allowed modes.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetDisplayActive(nvmlDevice device, ref nvmlEnableState isActive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">isActive</span></td>
        <td><p>Reference in which to return the display active state</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a isActive has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isActive is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetDisplayMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetDisplayMode*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetDisplayMode_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetDisplayMode(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState@)">nvmlDeviceGetDisplayMode(nvmlDevice, ref nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Retrieves the display mode for the device.
For all products.
This method indicates whether a physical display (e.g. monitor) is currently connected to
any of the device's connectors.
See \ref nvmlEnableState for details on allowed modes.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetDisplayMode(nvmlDevice device, ref nvmlEnableState display)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">display</span></td>
        <td><p>Reference in which to return the display mode</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a display has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a display is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetDriverModel_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetDriverModel*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetDriverModel_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlDriverModel__ManagedCuda_Nvml_nvmlDriverModel__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetDriverModel(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlDriverModel@,ManagedCuda.Nvml.nvmlDriverModel@)">nvmlDeviceGetDriverModel(nvmlDevice, ref nvmlDriverModel, ref nvmlDriverModel)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current and pending driver model for the device.
For Fermi or newer fully supported devices.
For windows only.
On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached
to the device it must run in WDDM mode. TCC mode is preferred if a display is not attached.
See \ref nvmlDriverModel for details on available driver models.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetDriverModel(nvmlDevice device, ref nvmlDriverModel current, ref nvmlDriverModel pending)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDriverModel.html">nvmlDriverModel</a></td>
        <td><span class="parametername">current</span></td>
        <td><p>Reference in which to return the current driver model</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDriverModel.html">nvmlDriverModel</a></td>
        <td><span class="parametername">pending</span></td>
        <td><p>Reference in which to return the pending driver model</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if either \a current and/or \a pending have been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or both \a current and \a pending are NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the platform is not windows
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceSetDriverModel()</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetEccMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetEccMode*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetEccMode_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState__ManagedCuda_Nvml_nvmlEnableState__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetEccMode(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState@,ManagedCuda.Nvml.nvmlEnableState@)">nvmlDeviceGetEccMode(nvmlDevice, ref nvmlEnableState, ref nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current and pending ECC modes for the device.
For Fermi or newer fully supported devices.
Only applicable to devices with ECC.
Requires \a NVML_INFOROM_ECC version 1.0 or higher.
Changing ECC modes requires a reboot. The &quot;pending&quot; ECC mode refers to the target mode following
the next reboot.
See \ref nvmlEnableState for details on allowed modes.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetEccMode(nvmlDevice device, ref nvmlEnableState current, ref nvmlEnableState pending)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">current</span></td>
        <td><p>Reference in which to return the current ECC mode</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">pending</span></td>
        <td><p>Reference in which to return the pending ECC mode</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a current and \a pending have been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or either \a current or \a pending is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceSetEccMode()</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetEncoderUtilization_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetEncoderUtilization*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetEncoderUtilization_ManagedCuda_Nvml_nvmlDevice_System_UInt32__System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetEncoderUtilization(ManagedCuda.Nvml.nvmlDevice,System.UInt32@,System.UInt32@)">nvmlDeviceGetEncoderUtilization(nvmlDevice, ref UInt32, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current utilization and sampling size in microseconds for the Encoder
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetEncoderUtilization(nvmlDevice device, ref uint utilization, ref uint samplingPeriodUs)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">utilization</span></td>
        <td><p>Reference to an uint for encoder utilization info</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">samplingPeriodUs</span></td>
        <td><p>Reference to an uint for the sampling period in US</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a utilization has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetEnforcedPowerLimit_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetEnforcedPowerLimit*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetEnforcedPowerLimit_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetEnforcedPowerLimit(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetEnforcedPowerLimit(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Get the effective power limit that the driver enforces after taking into account all limiters
Note: This can be different from the \ref nvmlDeviceGetPowerManagementLimit if other limits are set elsewhere
This includes the out of band power limit interface
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetEnforcedPowerLimit(nvmlDevice device, ref uint limit)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The device to communicate with</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">limit</span></td>
        <td><p>Reference in which to return the power management limit in milliwatts</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a limit has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a limit is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetFanSpeed_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetFanSpeed*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetFanSpeed_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetFanSpeed(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetFanSpeed(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the intended operating speed of the device's fan.
Note: The reported speed is the intended fan speed.  If the fan is physically blocked and unable to spin, the
output will not match the actual fan speed.</p>
<p>For all discrete products with dedicated fans.
The fan speed is expressed as a percent of the maximum, i.e. full speed is 100%.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetFanSpeed(nvmlDevice device, ref uint speed)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">speed</span></td>
        <td><p>Reference in which to return the fan speed percentage</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a speed has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a speed is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a fan</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetGpuOperationMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetGpuOperationMode*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetGpuOperationMode_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlGpuOperationMode__ManagedCuda_Nvml_nvmlGpuOperationMode__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetGpuOperationMode(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlGpuOperationMode@,ManagedCuda.Nvml.nvmlGpuOperationMode@)">nvmlDeviceGetGpuOperationMode(nvmlDevice, ref nvmlGpuOperationMode, ref nvmlGpuOperationMode)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current GOM and pending GOM (the one that GPU will switch to after reboot).
For GK110 M-class and X-class Tesla products from the Kepler family.
Modes \ref NVML_GOM_LOW_DP and \ref NVML_GOM_ALL_ON are supported on fully supported GeForce products.
Not supported on Quadro and Tesla C-class products.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetGpuOperationMode(nvmlDevice device, ref nvmlGpuOperationMode current, ref nvmlGpuOperationMode pending)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlGpuOperationMode.html">nvmlGpuOperationMode</a></td>
        <td><span class="parametername">current</span></td>
        <td><p>Reference in which to return the current GOM</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlGpuOperationMode.html">nvmlGpuOperationMode</a></td>
        <td><span class="parametername">pending</span></td>
        <td><p>Reference in which to return the pending GOM</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a mode has been populated
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a current or \a pending is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlGpuOperationMode
@see nvmlDeviceSetGpuOperationMode</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetGraphicsRunningProcesses_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetGraphicsRunningProcesses*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetGraphicsRunningProcesses_ManagedCuda_Nvml_nvmlDevice_System_UInt32__ManagedCuda_Nvml_nvmlProcessInfo___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetGraphicsRunningProcesses(ManagedCuda.Nvml.nvmlDevice,System.UInt32@,ManagedCuda.Nvml.nvmlProcessInfo[])">nvmlDeviceGetGraphicsRunningProcesses(nvmlDevice, ref UInt32, nvmlProcessInfo[])</h4>
  <div class="markdown level1 summary"><p>Get information about processes with a graphics context on a device
For Kepler or newer fully supported devices.
This function returns information only about graphics based processes
(eg. applications using OpenGL, DirectX)
To query the current number of running graphics processes, call this function with *infoCount = 0. The
return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call
\a infos is allowed to be NULL.
The usedGpuMemory field returned is all of the memory used by the application.
Keep in mind that information returned by this call is dynamic and the number of elements might change in
time. Allocate more space for \a infos table in case new graphics processes are spawned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetGraphicsRunningProcesses(nvmlDevice device, ref uint infoCount, nvmlProcessInfo[] infos)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">infoCount</span></td>
        <td><p>Reference in which to provide the \a infos array size, and</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlProcessInfo.html">nvmlProcessInfo</a>[]</td>
        <td><span class="parametername">infos</span></td>
        <td><p>Reference in which to return the process information</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a infoCount and \a infos have been populated
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INSUFFICIENT_SIZE if \a infoCount indicates that the \a infos array is too small
                                    \a infoCount will contain minimal amount of space necessary for
                                    the call to complete
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, either of \a infoCount or \a infos is NULL
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see \ref nvmlSystemGetProcessName</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetHandleByIndex_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetHandleByIndex*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetHandleByIndex_System_UInt32_ManagedCuda_Nvml_nvmlDevice__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetHandleByIndex(System.UInt32,ManagedCuda.Nvml.nvmlDevice@)">nvmlDeviceGetHandleByIndex(UInt32, ref nvmlDevice)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetHandleByIndex(uint index, ref nvmlDevice device)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">index</span></td>
        <td></td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetHandleByPciBusId_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetHandleByPciBusId*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetHandleByPciBusId_System_String_ManagedCuda_Nvml_nvmlDevice__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetHandleByPciBusId(System.String,ManagedCuda.Nvml.nvmlDevice@)">nvmlDeviceGetHandleByPciBusId(String, ref nvmlDevice)</h4>
  <div class="markdown level1 summary"><p>Acquire the handle for a particular device, based on its PCI bus id.</p>
<p>For all products.
This value corresponds to the nvmlPciInfo::busId returned by \ref nvmlDeviceGetPciInfo().
Starting from NVML 5, this API causes NVML to initialize the target GPU
NVML may initialize additional GPUs if:</p>
<ul>
<li>The target GPU is an SLI slave
\note NVML 4.304 and older version of nvmlDeviceGetHandleByPciBusId&quot;_v1&quot; returns NVML_ERROR_NOT_FOUND
instead of NVML_ERROR_NO_PERMISSION.</li>
</ul>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetHandleByPciBusId(string pciBusId, ref nvmlDevice device)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">pciBusId</span></td>
        <td><p>The PCI bus id of the target GPU</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>Reference in which to return the device handle</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                  if \a device has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT   if \a pciBusId is invalid or \a device is NULL</li>
<li>\ref NVML_ERROR_NOT_FOUND          if \a pciBusId does not match a valid device on the system</li>
<li>\ref NVML_ERROR_INSUFFICIENT_POWER if the attached device has improperly attached external power cables</li>
<li>\ref NVML_ERROR_NO_PERMISSION      if the user doesn't have permission to talk to this device</li>
<li>\ref NVML_ERROR_IRQ_ISSUE          if NVIDIA kernel detected an interrupt issue with the attached GPUs</li>
<li>\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN            on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetHandleByUUID_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetHandleByUUID*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetHandleByUUID_System_String_ManagedCuda_Nvml_nvmlDevice__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetHandleByUUID(System.String,ManagedCuda.Nvml.nvmlDevice@)">nvmlDeviceGetHandleByUUID(String, ref nvmlDevice)</h4>
  <div class="markdown level1 summary"><p>Acquire the handle for a particular device, based on its globally unique immutable UUID associated with each device.
For all products.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetHandleByUUID(string uuid, ref nvmlDevice device)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">uuid</span></td>
        <td><p>The UUID of the target GPU</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>Reference in which to return the device handle</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                  if \a device has been set
- \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT   if \a uuid is invalid or \a device is null
- \ref NVML_ERROR_NOT_FOUND          if \a uuid does not match a valid device on the system
- \ref NVML_ERROR_INSUFFICIENT_POWER if any attached devices have improperly attached external power cables
- \ref NVML_ERROR_IRQ_ISSUE          if NVIDIA kernel detected an interrupt issue with the attached GPUs
- \ref NVML_ERROR_GPU_IS_LOST        if any GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN            on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetUUID</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetIndex_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetIndex*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetIndex_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetIndex(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetIndex(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the NVML index of this device.
For all products.</p>
<p>Valid indices are derived from the \a accessibleDevices count returned by
\ref nvmlDeviceGetCount(). For example, if \a accessibleDevices is 2 the valid indices<br>
are 0 and 1, corresponding to GPU 0 and GPU 1.
The order in which NVML enumerates devices has no guarantees of consistency between reboots. For that reason it
is recommended that devices be looked up by their PCI ids or GPU UUID. See
\ref nvmlDeviceGetHandleByPciBusId() and \ref nvmlDeviceGetHandleByUUID().
Note: The NVML index may not correlate with other APIs, such as the CUDA device index.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetIndex(nvmlDevice device, ref uint index)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>Reference in which to return the NVML index of the device</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a index has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a index is NULL
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetHandleByIndex()
@see nvmlDeviceGetCount()</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetInforomConfigurationChecksum_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetInforomConfigurationChecksum*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetInforomConfigurationChecksum_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetInforomConfigurationChecksum(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetInforomConfigurationChecksum(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the checksum of the configuration stored in the device's infoROM.
For all products with an inforom.
Can be used to make sure that two GPUs have the exact same configuration.
Current checksum takes into account configuration stored in PWR and ECC infoROM objects.
Checksum can change between driver releases or when user changes configuration (e.g. disable/enable ECC)</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetInforomConfigurationChecksum(nvmlDevice device, ref uint checksum)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">checksum</span></td>
        <td><p>Reference in which to return the infoROM configuration checksum</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a checksum has been set</li>
<li>\ref NVML_ERROR_CORRUPTED_INFOROM if the device's checksum couldn't be retrieved due to infoROM corruption</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a checksum is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  <span class="small pull-right mobile-hide">
    <span class="divider">|</span>
    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetInforomImageVersion_ManagedCuda_Nvml_nvmlDevice_System_String__.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetInforomImageVersion(ManagedCuda.Nvml.nvmlDevice%2CSystem.String%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
  </span>
  <span class="small pull-right mobile-hide">
    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L876">View Source</a>
  </span>
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetInforomImageVersion_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetInforomImageVersion*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetInforomImageVersion_ManagedCuda_Nvml_nvmlDevice_System_String__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetInforomImageVersion(ManagedCuda.Nvml.nvmlDevice,System.String@)">nvmlDeviceGetInforomImageVersion(nvmlDevice, out String)</h4>
  <div class="markdown level1 summary"><p>Retrieves the global infoROM image version
For all products with an inforom.
Image version just like VBIOS version uniquely describes the exact version of the infoROM flashed on the board
in contrast to infoROM object version which is only an indicator of supported features.
Version string will not exceed 16 characters in length (including the NULL terminator).
See \ref nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetInforomImageVersion(nvmlDevice device, out string version)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">version</span></td>
        <td><p>Reference in which to return the infoROM image version</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a version has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL
- \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small 
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetInforomVersion</p>
</td>
      </tr>
    </tbody>
  </table>
  <span class="small pull-right mobile-hide">
    <span class="divider">|</span>
    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetInforomVersion_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlInforomObject_System_String__.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetInforomVersion(ManagedCuda.Nvml.nvmlDevice%2CManagedCuda.Nvml.nvmlInforomObject%2CSystem.String%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
  </span>
  <span class="small pull-right mobile-hide">
    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L839">View Source</a>
  </span>
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetInforomVersion_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetInforomVersion*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetInforomVersion_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlInforomObject_System_String__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetInforomVersion(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlInforomObject,System.String@)">nvmlDeviceGetInforomVersion(nvmlDevice, nvmlInforomObject, out String)</h4>
  <div class="markdown level1 summary"><p>Retrieves the version information for the device's infoROM object.
For all products with an inforom.
Fermi and higher parts have non-volatile on-board memory for persisting device info, such as aggregate
ECC counts. The version of the data structures in this memory may change from time to time. It will not
exceed 16 characters in length (including the NULL terminator).
See \ref nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE.
See \ref nvmlInforomObject for details on the available infoROM objects.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetInforomVersion(nvmlDevice device, nvmlInforomObject IRobject, out string version)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlInforomObject.html">nvmlInforomObject</a></td>
        <td><span class="parametername">IRobject</span></td>
        <td><p>The target infoROM object</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">version</span></td>
        <td><p>Reference in which to return the infoROM version</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a version has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL
- \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small 
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetInforomImageVersion</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMaxClockInfo_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMaxClockInfo*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMaxClockInfo_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlClockType_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMaxClockInfo(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlClockType,System.UInt32@)">nvmlDeviceGetMaxClockInfo(nvmlDevice, nvmlClockType, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the maximum clock speeds for the device.
For Fermi or newer fully supported devices.
See \ref nvmlClockType for details on available clock information.
\note On GPUs from Fermi family current P0 clocks (reported by \ref nvmlDeviceGetClockInfo) can differ from max clocks
by few MHz.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetMaxClockInfo(nvmlDevice device, nvmlClockType type, ref uint clock)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlClockType.html">nvmlClockType</a></td>
        <td><span class="parametername">type</span></td>
        <td><p>Identify which clock domain to query</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">clock</span></td>
        <td><p>Reference in which to return the clock speed in MHz</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a clock has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMaxCustomerBoostClock_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMaxCustomerBoostClock*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMaxCustomerBoostClock_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlClockType_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMaxCustomerBoostClock(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlClockType,System.UInt32@)">nvmlDeviceGetMaxCustomerBoostClock(nvmlDevice, nvmlClockType, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the customer defined maximum boost clock speed specified by the given clock type.
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetMaxCustomerBoostClock(nvmlDevice device, nvmlClockType clockType, ref uint clockMHz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlClockType.html">nvmlClockType</a></td>
        <td><span class="parametername">clockType</span></td>
        <td><p>Identify which clock domain to query</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">clockMHz</span></td>
        <td><p>Reference in which to return the clock in MHz</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a clockMHz has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device or the \a clockType on this device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMaxPcieLinkGeneration_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMaxPcieLinkGeneration*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMaxPcieLinkGeneration_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMaxPcieLinkGeneration(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetMaxPcieLinkGeneration(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the maximum PCIe link generation possible with this device and system
I.E. for a generation 2 PCIe device attached to a generation 1 PCIe bus the max link generation this function will
report is generation 1.</p>
<p>For Fermi or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetMaxPcieLinkGeneration(nvmlDevice device, ref uint maxLinkGen)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">maxLinkGen</span></td>
        <td><p>Reference in which to return the max PCIe link generation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a maxLinkGen has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a maxLinkGen is null</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMaxPcieLinkWidth_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMaxPcieLinkWidth*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMaxPcieLinkWidth_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMaxPcieLinkWidth(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetMaxPcieLinkWidth(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the maximum PCIe link width possible with this device and system
I.E. for a device with a 16x PCIe bus width attached to a 8x PCIe system bus this function will report
a max link width of 8.</p>
<p>For Fermi or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetMaxPcieLinkWidth(nvmlDevice device, ref uint maxLinkWidth)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">maxLinkWidth</span></td>
        <td><p>Reference in which to return the max PCIe link generation</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a maxLinkWidth has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a maxLinkWidth is null</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMemoryErrorCounter_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMemoryErrorCounter*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMemoryErrorCounter_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlMemoryErrorType_ManagedCuda_Nvml_nvmlEccCounterType_ManagedCuda_Nvml_nvmlMemoryLocation_System_UInt64__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMemoryErrorCounter(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlMemoryErrorType,ManagedCuda.Nvml.nvmlEccCounterType,ManagedCuda.Nvml.nvmlMemoryLocation,System.UInt64@)">nvmlDeviceGetMemoryErrorCounter(nvmlDevice, nvmlMemoryErrorType, nvmlEccCounterType, nvmlMemoryLocation, ref UInt64)</h4>
  <div class="markdown level1 summary"><p>Retrieves the requested memory error counter for the device.
For Fermi or newer fully supported devices.
Requires \a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based memory error counts.
Requires \a NVML_INFOROM_ECC version 1.0 or higher to report all other memory error counts.
Only applicable to devices with ECC.
Requires ECC Mode to be enabled.
See \ref nvmlMemoryErrorType for a description of available memory error types.\n
See \ref nvmlEccCounterType for a description of available counter types.\n
See \ref nvmlMemoryLocation for a description of available counter locations.\n</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetMemoryErrorCounter(nvmlDevice device, nvmlMemoryErrorType errorType, nvmlEccCounterType counterType, nvmlMemoryLocation locationType, ref ulong count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlMemoryErrorType.html">nvmlMemoryErrorType</a></td>
        <td><span class="parametername">errorType</span></td>
        <td><p>Flag that specifies the type of error.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEccCounterType.html">nvmlEccCounterType</a></td>
        <td><span class="parametername">counterType</span></td>
        <td><p>Flag that specifies the counter-type of the errors.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlMemoryLocation.html">nvmlMemoryLocation</a></td>
        <td><span class="parametername">locationType</span></td>
        <td><p>Specifies the location of the counter.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>Reference in which to return the ECC counter</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a count has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a bitTyp,e \a counterType or \a locationType is
invalid, or \a count is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support ECC error reporting in the specified memory</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMemoryInfo_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMemoryInfo*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMemoryInfo_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlMemory__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMemoryInfo(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlMemory@)">nvmlDeviceGetMemoryInfo(nvmlDevice, ref nvmlMemory)</h4>
  <div class="markdown level1 summary"><p>Retrieves the amount of used, free and total memory available on the device, in bytes.</p>
<p>For all products.
Enabling ECC reduces the amount of total available memory, due to the extra required parity bits.
Under WDDM most device memory is allocated and managed on startup by Windows.
Under Linux and Windows TCC, the reported amount of used memory is equal to the sum of memory allocated
by all active channels on the device.
See \ref nvmlMemory for details on available memory info.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetMemoryInfo(nvmlDevice device, ref nvmlMemory memory)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlMemory.html">nvmlMemory</a></td>
        <td><span class="parametername">memory</span></td>
        <td><p>Reference in which to return the memory information</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a memory has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a memory is NULL</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMinorNumber_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMinorNumber*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMinorNumber_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMinorNumber(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetMinorNumber(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves minor number for the device. The minor number for the device is such that the Nvidia device node file for
each GPU will have the form /dev/nvidia[minor number].
For all products.
Supported only for Linux</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetMinorNumber(nvmlDevice device, ref uint minorNumber)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">minorNumber</span></td>
        <td><p>Reference in which to return the minor number for the device</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if the minor number is successfully retrieved</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a minorNumber is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMultiGpuBoard_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMultiGpuBoard*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetMultiGpuBoard_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetMultiGpuBoard(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetMultiGpuBoard(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves whether the device is on a Multi-GPU Board
Devices that are on multi-GPU boards will set \a multiGpuBool to a non-zero value.
For Fermi or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetMultiGpuBoard(nvmlDevice device, ref uint multiGpuBool)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">multiGpuBool</span></td>
        <td><p>Reference in which to return a zero or non-zero value</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a multiGpuBool has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a multiGpuBool is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  <span class="small pull-right mobile-hide">
    <span class="divider">|</span>
    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetName_ManagedCuda_Nvml_nvmlDevice_System_String__.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetName(ManagedCuda.Nvml.nvmlDevice%2CSystem.String%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
  </span>
  <span class="small pull-right mobile-hide">
    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L509">View Source</a>
  </span>
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetName_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetName*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetName_ManagedCuda_Nvml_nvmlDevice_System_String__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetName(ManagedCuda.Nvml.nvmlDevice,System.String@)">nvmlDeviceGetName(nvmlDevice, out String)</h4>
  <div class="markdown level1 summary"><p>Retrieves the name of this device.</p>
<p>For all products.
The name is an alphanumeric string that denotes a particular product, e.g. Tesla C2070. It will not
exceed 64 characters in length (including the NULL terminator).  See \ref
nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetName(nvmlDevice device, out string name)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td><p>Reference in which to return the product name</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a name has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a name is NULL</li>
<li>\ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkCapability_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkCapability*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkCapability_ManagedCuda_Nvml_nvmlDevice_System_UInt32_ManagedCuda_Nvml_nvmlNvLinkCapability_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkCapability(ManagedCuda.Nvml.nvmlDevice,System.UInt32,ManagedCuda.Nvml.nvmlNvLinkCapability,System.UInt32@)">nvmlDeviceGetNvLinkCapability(nvmlDevice, UInt32, nvmlNvLinkCapability, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the requested capability from the device's NvLink for the link specified
Please refer to the \a nvmlNvLinkCapability structure for the specific caps that can be queried
The return value should be treated as a boolean.
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetNvLinkCapability(nvmlDevice device, uint link, nvmlNvLinkCapability capability, ref uint capResult)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">link</span></td>
        <td><p>Specifies the NvLink link to be queried</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlNvLinkCapability.html">nvmlNvLinkCapability</a></td>
        <td><span class="parametername">capability</span></td>
        <td><p>Specifies the \a nvmlNvLinkCapability to be queried</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">capResult</span></td>
        <td><p>A boolean for the queried capability indicating that feature is available</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a capResult has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a capability is invalid or \a capResult is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkErrorCounter_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkErrorCounter*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkErrorCounter_ManagedCuda_Nvml_nvmlDevice_System_UInt32_ManagedCuda_Nvml_nvmlNvLinkErrorCounter_System_UInt64__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkErrorCounter(ManagedCuda.Nvml.nvmlDevice,System.UInt32,ManagedCuda.Nvml.nvmlNvLinkErrorCounter,System.UInt64@)">nvmlDeviceGetNvLinkErrorCounter(nvmlDevice, UInt32, nvmlNvLinkErrorCounter, ref UInt64)</h4>
  <div class="markdown level1 summary"><p>Retrieves the specified error counter value
Please refer to \a nvmlNvLinkErrorCounter for error counters that are available
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetNvLinkErrorCounter(nvmlDevice device, uint link, nvmlNvLinkErrorCounter counter, ref ulong counterValue)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">link</span></td>
        <td><p>Specifies the NvLink link to be queried</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlNvLinkErrorCounter.html">nvmlNvLinkErrorCounter</a></td>
        <td><span class="parametername">counter</span></td>
        <td><p>Specifies the NvLink counter to be queried</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span></td>
        <td><span class="parametername">counterValue</span></td>
        <td><p>Returned counter value</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a counter has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a counter is invalid or \a counterValue is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkRemotePciInfo_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkRemotePciInfo*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkRemotePciInfo_ManagedCuda_Nvml_nvmlDevice_System_UInt32_ManagedCuda_Nvml_nvmlPciInfo__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkRemotePciInfo(ManagedCuda.Nvml.nvmlDevice,System.UInt32,ManagedCuda.Nvml.nvmlPciInfo@)">nvmlDeviceGetNvLinkRemotePciInfo(nvmlDevice, UInt32, ref nvmlPciInfo)</h4>
  <div class="markdown level1 summary"><p>Retrieves the PCI information for the remote node on a NvLink link
Note: pciSubSystemId is not filled in this function and is indeterminate
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetNvLinkRemotePciInfo(nvmlDevice device, uint link, ref nvmlPciInfo pci)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">link</span></td>
        <td><p>Specifies the NvLink link to be queried</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlPciInfo.html">nvmlPciInfo</a></td>
        <td><span class="parametername">pci</span></td>
        <td><p>\a nvmlPciInfo of the remote node for the specified link</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a pci has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid or \a pci is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkState*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkState_ManagedCuda_Nvml_nvmlDevice_System_UInt32_ManagedCuda_Nvml_nvmlEnableState__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkState(ManagedCuda.Nvml.nvmlDevice,System.UInt32,ManagedCuda.Nvml.nvmlEnableState@)">nvmlDeviceGetNvLinkState(nvmlDevice, UInt32, ref nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Retrieves the state of the device's NvLink for the link specified
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetNvLinkState(nvmlDevice device, uint link, ref nvmlEnableState isActive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">link</span></td>
        <td><p>Specifies the NvLink link to be queried</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">isActive</span></td>
        <td><p>\a nvmlEnableState where NVML_FEATURE_ENABLED indicates that</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a isActive has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid or \a isActive is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkUtilizationControl_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkUtilizationControl*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkUtilizationControl_ManagedCuda_Nvml_nvmlDevice_System_UInt32_System_UInt32_ManagedCuda_Nvml_nvmlNvLinkUtilizationControl__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkUtilizationControl(ManagedCuda.Nvml.nvmlDevice,System.UInt32,System.UInt32,ManagedCuda.Nvml.nvmlNvLinkUtilizationControl@)">nvmlDeviceGetNvLinkUtilizationControl(nvmlDevice, UInt32, UInt32, ref nvmlNvLinkUtilizationControl)</h4>
  <div class="markdown level1 summary"><p>Get the NVLINK utilization counter control information for the specified counter, 0 or 1.
Please refer to \a nvmlNvLinkUtilizationControl for the structure definition
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetNvLinkUtilizationControl(nvmlDevice device, uint link, uint counter, ref nvmlNvLinkUtilizationControl control)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">link</span></td>
        <td><p>Specifies the NvLink link to be queried</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">counter</span></td>
        <td><p>Specifies the counter that should be set (0 or 1).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlNvLinkUtilizationControl.html">nvmlNvLinkUtilizationControl</a></td>
        <td><span class="parametername">control</span></td>
        <td><p>A reference to the \a nvmlNvLinkUtilizationControl to place information</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if the control has been set successfully</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, \a link, or \a control is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkUtilizationCounter_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkUtilizationCounter*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkUtilizationCounter_ManagedCuda_Nvml_nvmlDevice_System_UInt32_System_UInt32_System_UInt64__System_UInt64__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkUtilizationCounter(ManagedCuda.Nvml.nvmlDevice,System.UInt32,System.UInt32,System.UInt64@,System.UInt64@)">nvmlDeviceGetNvLinkUtilizationCounter(nvmlDevice, UInt32, UInt32, ref UInt64, ref UInt64)</h4>
  <div class="markdown level1 summary"><p>Retrieve the NVLINK utilization counter based on the current control for a specified counter.
In general it is good practice to use \a nvmlDeviceSetNvLinkUtilizationControl
before reading the utilization counters as they have no default state
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetNvLinkUtilizationCounter(nvmlDevice device, uint link, uint counter, ref ulong rxcounter, ref ulong txcounter)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">link</span></td>
        <td><p>Specifies the NvLink link to be queried</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">counter</span></td>
        <td><p>Specifies the counter that should be read (0 or 1).</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span></td>
        <td><span class="parametername">rxcounter</span></td>
        <td><p>Receive counter return value</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span></td>
        <td><span class="parametername">txcounter</span></td>
        <td><p>Transmit counter return value</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a rxcounter and \a txcounter have been successfully set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, or \a link is invalid or \a rxcounter or \a txcounter are NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkVersion_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkVersion*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetNvLinkVersion_ManagedCuda_Nvml_nvmlDevice_System_UInt32_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetNvLinkVersion(ManagedCuda.Nvml.nvmlDevice,System.UInt32,System.UInt32@)">nvmlDeviceGetNvLinkVersion(nvmlDevice, UInt32, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the version of the device's NvLink for the link specified
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetNvLinkVersion(nvmlDevice device, uint link, ref uint version)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">link</span></td>
        <td><p>Specifies the NvLink link to be queried</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">version</span></td>
        <td><p>Requested NvLink version</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a version has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid or \a version is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPcieReplayCounter_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPcieReplayCounter*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPcieReplayCounter_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPcieReplayCounter(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetPcieReplayCounter(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieve the PCIe replay counter.
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetPcieReplayCounter(nvmlDevice device, ref uint value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>Reference in which to return the counter's value</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a value and \a rollover have been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a value or \a rollover are NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPcieThroughput_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPcieThroughput*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPcieThroughput_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlPcieUtilCounter_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPcieThroughput(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlPcieUtilCounter,System.UInt32@)">nvmlDeviceGetPcieThroughput(nvmlDevice, nvmlPcieUtilCounter, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieve PCIe utilization information.
This function is querying a byte counter over a 20ms interval and thus is the
PCIe throughput over that interval.
For Maxwell or newer fully supported devices.
This method is not supported on virtualized GPU environments.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetPcieThroughput(nvmlDevice device, nvmlPcieUtilCounter counter, ref uint value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlPcieUtilCounter.html">nvmlPcieUtilCounter</a></td>
        <td><span class="parametername">counter</span></td>
        <td><p>The specific counter that should be queried \ref nvmlPcieUtilCounter</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>Reference in which to return throughput in KB/s</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a value has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a counter is invalid, or \a value is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPciInfo_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPciInfo*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPciInfo_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlPciInfo__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPciInfo(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlPciInfo@)">nvmlDeviceGetPciInfo(nvmlDevice, ref nvmlPciInfo)</h4>
  <div class="markdown level1 summary"><p>Retrieves the PCI attributes of this device.</p>
<p>For all products.
See \ref nvmlPciInfo for details on the available PCI info.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetPciInfo(nvmlDevice device, ref nvmlPciInfo pci)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlPciInfo.html">nvmlPciInfo</a></td>
        <td><span class="parametername">pci</span></td>
        <td><p>Reference in which to return the PCI info</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a pci has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a pci is NULL</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPerformanceState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPerformanceState*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPerformanceState_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlPstates__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPerformanceState(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlPstates@)">nvmlDeviceGetPerformanceState(nvmlDevice, ref nvmlPstates)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current performance state for the device.
For Fermi or newer fully supported devices.
See \ref nvmlPstates for details on allowed performance states.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetPerformanceState(nvmlDevice device, ref nvmlPstates pState)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlPstates.html">nvmlPstates</a></td>
        <td><span class="parametername">pState</span></td>
        <td><p>Reference in which to return the performance state reading</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a pState has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a pState is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPersistenceMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPersistenceMode*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPersistenceMode_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPersistenceMode(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState@)">nvmlDeviceGetPersistenceMode(nvmlDevice, ref nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Retrieves the persistence mode associated with this device.
For all products.
For Linux only.
When driver persistence mode is enabled the driver software state is not torn down when the last
client disconnects. By default this feature is disabled.
See \ref nvmlEnableState for details on allowed modes.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetPersistenceMode(nvmlDevice device, ref nvmlEnableState mode)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">mode</span></td>
        <td><p>Reference in which to return the current driver persistence mode</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a mode has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceSetPersistenceMode()</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPowerManagementDefaultLimit_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPowerManagementDefaultLimit*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPowerManagementDefaultLimit_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPowerManagementDefaultLimit(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetPowerManagementDefaultLimit(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves default power management limit on this device, in milliwatts.
Default power management limit is a power management limit that the device boots with.
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetPowerManagementDefaultLimit(nvmlDevice device, ref uint defaultLimit)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">defaultLimit</span></td>
        <td><p>Reference in which to return the default power management limit in milliwatts</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a defaultLimit has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a defaultLimit is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPowerManagementLimit_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPowerManagementLimit*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPowerManagementLimit_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPowerManagementLimit(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetPowerManagementLimit(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the power management limit associated with this device.
For Fermi or newer fully supported devices.
The power limit defines the upper boundary for the card's power draw. If
the card's total power draw reaches this limit the power management algorithm kicks in.
This reading is only available if power management mode is supported.
See \ref nvmlDeviceGetPowerManagementMode.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetPowerManagementLimit(nvmlDevice device, ref uint limit)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">limit</span></td>
        <td><p>Reference in which to return the power management limit in milliwatts</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a limit has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a limit is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPowerManagementLimitConstraints_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPowerManagementLimitConstraints*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPowerManagementLimitConstraints_ManagedCuda_Nvml_nvmlDevice_System_UInt32__System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPowerManagementLimitConstraints(ManagedCuda.Nvml.nvmlDevice,System.UInt32@,System.UInt32@)">nvmlDeviceGetPowerManagementLimitConstraints(nvmlDevice, ref UInt32, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves information about possible values of power management limits on this device.
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetPowerManagementLimitConstraints(nvmlDevice device, ref uint minLimit, ref uint maxLimit)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">minLimit</span></td>
        <td><p>Reference in which to return the minimum power management limit in milliwatts</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">maxLimit</span></td>
        <td><p>Reference in which to return the maximum power management limit in milliwatts</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a minLimit and \a maxLimit have been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a minLimit or \a maxLimit is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceSetPowerManagementLimit</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPowerUsage_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPowerUsage*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetPowerUsage_ManagedCuda_Nvml_nvmlDevice_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetPowerUsage(ManagedCuda.Nvml.nvmlDevice,System.UInt32@)">nvmlDeviceGetPowerUsage(nvmlDevice, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves power usage for this GPU in milliwatts and its associated circuitry (e.g. memory)
For Fermi or newer fully supported devices.
On Fermi and Kepler GPUs the reading is accurate to within +/- 5% of current power draw.
It is only available if power management mode is supported. See \ref nvmlDeviceGetPowerManagementMode.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetPowerUsage(nvmlDevice device, ref uint power)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">power</span></td>
        <td><p>Reference in which to return the power usage information</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a power has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a power is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support power readings</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetRetiredPages_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetRetiredPages*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetRetiredPages_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlPageRetirementCause_System_UInt32__System_UInt64___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetRetiredPages(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlPageRetirementCause,System.UInt32@,System.UInt64[])">nvmlDeviceGetRetiredPages(nvmlDevice, nvmlPageRetirementCause, ref UInt32, UInt64[])</h4>
  <div class="markdown level1 summary"><p>Returns the list of retired pages by source, including pages that are pending retirement
The address information provided from this API is the hardware address of the page that was retired.  Note
that this does not match the virtual address used in CUDA, but will match the address information in XID 63</p>
<p>For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetRetiredPages(nvmlDevice device, nvmlPageRetirementCause cause, ref uint pageCount, ulong[] addresses)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlPageRetirementCause.html">nvmlPageRetirementCause</a></td>
        <td><span class="parametername">cause</span></td>
        <td><p>Filter page addresses by cause of retirement</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">pageCount</span></td>
        <td><p>Reference in which to provide the \a addresses buffer size, and</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span>[]</td>
        <td><span class="parametername">addresses</span></td>
        <td><p>Buffer to write the page addresses into</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a pageCount was populated and \a addresses was filled</li>
<li>\ref NVML_ERROR_INSUFFICIENT_SIZE if \a pageCount indicates the buffer is not large enough to store all the
matching page addresses.  \a pageCount is set to the needed size.</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a pageCount is NULL, \a cause is invalid, or
\a addresses is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetRetiredPagesPendingStatus_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetRetiredPagesPendingStatus*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetRetiredPagesPendingStatus_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetRetiredPagesPendingStatus(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState@)">nvmlDeviceGetRetiredPagesPendingStatus(nvmlDevice, ref nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Check if any pages are pending retirement and need a reboot to fully retire.
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetRetiredPagesPendingStatus(nvmlDevice device, ref nvmlEnableState isPending)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">isPending</span></td>
        <td><p>Reference in which to return the pending status</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a isPending was populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isPending is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSamples_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSamples*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSamples_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlSamplingType_System_UInt64_ManagedCuda_Nvml_nvmlValueType__System_UInt32__ManagedCuda_Nvml_nvmlSample___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSamples(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlSamplingType,System.UInt64,ManagedCuda.Nvml.nvmlValueType@,System.UInt32@,ManagedCuda.Nvml.nvmlSample[])">nvmlDeviceGetSamples(nvmlDevice, nvmlSamplingType, UInt64, ref nvmlValueType, ref UInt32, nvmlSample[])</h4>
  <div class="markdown level1 summary"><p>Gets recent samples for the GPU.</p>
<p>For Kepler or newer fully supported devices.</p>
<p>Based on type, this method can be used to fetch the power, utilization or clock samples maintained in the buffer by
the driver.</p>
<p>Power, Utilization and Clock samples are returned as type &quot;uint&quot; for the union nvmlValue.</p>
<p>To get the size of samples that user needs to allocate, the method is invoked with samples set to NULL.
The returned samplesCount will provide the number of samples that can be queried. The user needs to
allocate the buffer with size as samplesCount		/// sizeof(nvmlSample).</p>
<p>lastSeenTimeStamp represents CPU timestamp in microseconds. Set it to 0 to fetch all the samples maintained by the
underlying buffer. Set lastSeenTimeStamp to one of the timeStamps retrieved from the date of the previous query
to get more recent samples.</p>
<p>This method fetches the number of entries which can be accommodated in the provided samples array, and the
reference samplesCount is updated to indicate how many samples were actually retrieved. The advantage of using this
method for samples in contrast to polling via existing methods is to get get higher frequency data at lower polling cost.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetSamples(nvmlDevice device, nvmlSamplingType type, ulong lastSeenTimeStamp, ref nvmlValueType sampleValType, ref uint sampleCount, nvmlSample[] samples)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier for the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlSamplingType.html">nvmlSamplingType</a></td>
        <td><span class="parametername">type</span></td>
        <td><p>Type of sampling event</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span></td>
        <td><span class="parametername">lastSeenTimeStamp</span></td>
        <td><p>Return only samples with timestamp greater than lastSeenTimeStamp.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlValueType.html">nvmlValueType</a></td>
        <td><span class="parametername">sampleValType</span></td>
        <td><p>Output parameter to represent the type of sample value as described in nvmlSampleVal</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">sampleCount</span></td>
        <td><p>Reference to provide the number of elements which can be queried in samples array</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlSample.html">nvmlSample</a>[]</td>
        <td><span class="parametername">samples</span></td>
        <td><p>Reference in which samples are returned</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if samples are successfully retrieved</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a samplesCount is NULL or
reference to \a sampleCount is 0 for non null \a samples</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_NOT_FOUND         if sample entries are not found</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  <span class="small pull-right mobile-hide">
    <span class="divider">|</span>
    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSerial_ManagedCuda_Nvml_nvmlDevice_System_String__.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSerial(ManagedCuda.Nvml.nvmlDevice%2CSystem.String%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
  </span>
  <span class="small pull-right mobile-hide">
    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L591">View Source</a>
  </span>
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSerial_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSerial*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSerial_ManagedCuda_Nvml_nvmlDevice_System_String__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSerial(ManagedCuda.Nvml.nvmlDevice,System.String@)">nvmlDeviceGetSerial(nvmlDevice, out String)</h4>
  <div class="markdown level1 summary"><p>Retrieves the globally unique board serial number associated with this device's board.
For all products with an inforom.
The serial number is an alphanumeric string that will not exceed 30 characters (including the NULL terminator).
This number matches the serial number tag that is physically attached to the board.  See \ref
nvmlConstants::NVML_DEVICE_SERIAL_BUFFER_SIZE.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetSerial(nvmlDevice device, out string serial)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">serial</span></td>
        <td><p>Reference in which to return the board/module serial number</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a serial has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a serial is NULL</li>
<li>\ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSupportedClocksThrottleReasons_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSupportedClocksThrottleReasons*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSupportedClocksThrottleReasons_ManagedCuda_Nvml_nvmlDevice_System_UInt64__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSupportedClocksThrottleReasons(ManagedCuda.Nvml.nvmlDevice,System.UInt64@)">nvmlDeviceGetSupportedClocksThrottleReasons(nvmlDevice, ref UInt64)</h4>
  <div class="markdown level1 summary"><p>Retrieves bitmask of supported clocks throttle reasons that can be returned by
\ref nvmlDeviceGetCurrentClocksThrottleReasons
For all fully supported products.
This method is not supported on virtualized GPU environments.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetSupportedClocksThrottleReasons(nvmlDevice device, ref ulong supportedClocksThrottleReasons)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span></td>
        <td><span class="parametername">supportedClocksThrottleReasons</span></td>
        <td><p>Reference in which to return bitmask of supported</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a supportedClocksThrottleReasons has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a supportedClocksThrottleReasons is NULL
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlClocksThrottleReasons
@see nvmlDeviceGetCurrentClocksThrottleReasons</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSupportedEventTypes_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSupportedEventTypes*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSupportedEventTypes_ManagedCuda_Nvml_nvmlDevice_System_UInt64__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSupportedEventTypes(ManagedCuda.Nvml.nvmlDevice,System.UInt64@)">nvmlDeviceGetSupportedEventTypes(nvmlDevice, ref UInt64)</h4>
  <div class="markdown level1 summary"><p>Returns information about events supported on device
For Fermi or newer fully supported devices.
Events are not supported on Windows. So this function returns an empty mask in \a eventTypes on Windows.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetSupportedEventTypes(nvmlDevice device, ref ulong eventTypes)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span></td>
        <td><span class="parametername">eventTypes</span></td>
        <td><p>Reference in which to return bitmask of supported events</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if the eventTypes has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a eventType is NULL
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlEventType
@see nvmlDeviceRegisterEvents</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSupportedGraphicsClocks_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSupportedGraphicsClocks*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSupportedGraphicsClocks_ManagedCuda_Nvml_nvmlDevice_System_UInt32_System_UInt32__System_UInt32___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSupportedGraphicsClocks(ManagedCuda.Nvml.nvmlDevice,System.UInt32,System.UInt32@,System.UInt32[])">nvmlDeviceGetSupportedGraphicsClocks(nvmlDevice, UInt32, ref UInt32, UInt32[])</h4>
  <div class="markdown level1 summary"><p>Retrieves the list of possible graphics clocks that can be used as an argument for \ref nvmlDeviceSetApplicationsClocks.
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetSupportedGraphicsClocks(nvmlDevice device, uint memoryClockMHz, ref uint count, uint[] clocksMHz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">memoryClockMHz</span></td>
        <td><p>Memory clock for which to return possible graphics clocks</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>Reference in which to provide the \a clocksMHz array size, and</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span>[]</td>
        <td><span class="parametername">clocksMHz</span></td>
        <td><p>Reference in which to return the clocks in MHz</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a count and \a clocksMHz have been populated 
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_NOT_FOUND         if the specified \a memoryClockMHz is not a supported frequency
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small 
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceSetApplicationsClocks
@see nvmlDeviceGetSupportedMemoryClocks</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSupportedMemoryClocks_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSupportedMemoryClocks*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetSupportedMemoryClocks_ManagedCuda_Nvml_nvmlDevice_System_UInt32__System_UInt32___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetSupportedMemoryClocks(ManagedCuda.Nvml.nvmlDevice,System.UInt32@,System.UInt32[])">nvmlDeviceGetSupportedMemoryClocks(nvmlDevice, ref UInt32, UInt32[])</h4>
  <div class="markdown level1 summary"><p>Retrieves the list of possible memory clocks that can be used as an argument for \ref nvmlDeviceSetApplicationsClocks.
For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetSupportedMemoryClocks(nvmlDevice device, ref uint count, uint[] clocksMHz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>Reference in which to provide the \a clocksMHz array size, and</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span>[]</td>
        <td><span class="parametername">clocksMHz</span></td>
        <td><p>Reference in which to return the clock in MHz</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a count and \a clocksMHz have been populated 
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a count is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set to the number of
                                       required elements)
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceSetApplicationsClocks
@see nvmlDeviceGetSupportedGraphicsClocks</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetTemperature_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetTemperature*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetTemperature_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlTemperatureSensors_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetTemperature(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlTemperatureSensors,System.UInt32@)">nvmlDeviceGetTemperature(nvmlDevice, nvmlTemperatureSensors, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current temperature readings for the device, in degrees C.</p>
<p>For all products.
See \ref nvmlTemperatureSensors for details on available temperature sensors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetTemperature(nvmlDevice device, nvmlTemperatureSensors sensorType, ref uint temp)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlTemperatureSensors.html">nvmlTemperatureSensors</a></td>
        <td><span class="parametername">sensorType</span></td>
        <td><p>Flag that indicates which sensor reading to retrieve</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">temp</span></td>
        <td><p>Reference in which to return the temperature reading</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a temp has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a sensorType is invalid or \a temp is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have the specified sensor</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetTemperatureThreshold_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetTemperatureThreshold*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetTemperatureThreshold_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlTemperatureThresholds_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetTemperatureThreshold(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlTemperatureThresholds,System.UInt32@)">nvmlDeviceGetTemperatureThreshold(nvmlDevice, nvmlTemperatureThresholds, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the temperature threshold for the GPU with the specified threshold type in degrees C.
For Kepler or newer fully supported devices.
See \ref nvmlTemperatureThresholds for details on available temperature thresholds.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetTemperatureThreshold(nvmlDevice device, nvmlTemperatureThresholds thresholdType, ref uint temp)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlTemperatureThresholds.html">nvmlTemperatureThresholds</a></td>
        <td><span class="parametername">thresholdType</span></td>
        <td><p>The type of threshold value queried</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">temp</span></td>
        <td><p>Reference in which to return the temperature reading</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a temp has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a thresholdType is invalid or \a temp is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a temperature sensor or is unsupported</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetTopologyCommonAncestor_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetTopologyCommonAncestor*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetTopologyCommonAncestor_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlGpuTopologyLevel__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetTopologyCommonAncestor(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlGpuTopologyLevel@)">nvmlDeviceGetTopologyCommonAncestor(nvmlDevice, nvmlDevice, ref nvmlGpuTopologyLevel)</h4>
  <div class="markdown level1 summary"><p>Retrieve the common ancestor for two devices
For all products.
Supported on Linux only.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetTopologyCommonAncestor(nvmlDevice device1, nvmlDevice device2, ref nvmlGpuTopologyLevel pathInfo)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device1</span></td>
        <td><p>The identifier of the first device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device2</span></td>
        <td><p>The identifier of the second device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlGpuTopologyLevel.html">nvmlGpuTopologyLevel</a></td>
        <td><span class="parametername">pathInfo</span></td>
        <td><p>A \ref nvmlGpuTopologyLevel that gives the path type</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a pathInfo has been set</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device1, or \a device2 is invalid, or \a pathInfo is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetTopologyNearestGpus_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetTopologyNearestGpus*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetTopologyNearestGpus_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlGpuTopologyLevel_System_UInt32__ManagedCuda_Nvml_nvmlDevice___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetTopologyNearestGpus(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlGpuTopologyLevel,System.UInt32@,ManagedCuda.Nvml.nvmlDevice[])">nvmlDeviceGetTopologyNearestGpus(nvmlDevice, nvmlGpuTopologyLevel, ref UInt32, nvmlDevice[])</h4>
  <div class="markdown level1 summary"><p>Retrieve the set of GPUs that are nearest to a given device at a specific interconnectivity level
For all products.
Supported on Linux only.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetTopologyNearestGpus(nvmlDevice device, nvmlGpuTopologyLevel level, ref uint count, nvmlDevice[] deviceArray)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the first device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlGpuTopologyLevel.html">nvmlGpuTopologyLevel</a></td>
        <td><span class="parametername">level</span></td>
        <td><p>The \ref nvmlGpuTopologyLevel level to search for other GPUs</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>When zero, is set to the number of matching GPUs such that \a deviceArray</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a>[]</td>
        <td><span class="parametername">deviceArray</span></td>
        <td><p>An array of device handles for GPUs found at \a level</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a deviceArray or \a count (if initially zero) has been set</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a level, or \a count is invalid, or \a deviceArray is NULL with a non-zero \a count</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetTotalEccErrors_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetTotalEccErrors*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetTotalEccErrors_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlMemoryErrorType_ManagedCuda_Nvml_nvmlEccCounterType_System_UInt64__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetTotalEccErrors(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlMemoryErrorType,ManagedCuda.Nvml.nvmlEccCounterType,System.UInt64@)">nvmlDeviceGetTotalEccErrors(nvmlDevice, nvmlMemoryErrorType, nvmlEccCounterType, ref UInt64)</h4>
  <div class="markdown level1 summary"><p>Retrieves the total ECC error counts for the device.
For Fermi or newer fully supported devices.
Only applicable to devices with ECC.
Requires \a NVML_INFOROM_ECC version 1.0 or higher.
Requires ECC Mode to be enabled.
The total error count is the sum of errors across each of the separate memory systems, i.e. the total set of
errors across the entire device.
See \ref nvmlMemoryErrorType for a description of available error types.\n
See \ref nvmlEccCounterType for a description of available counter types.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetTotalEccErrors(nvmlDevice device, nvmlMemoryErrorType errorType, nvmlEccCounterType counterType, ref ulong eccCounts)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlMemoryErrorType.html">nvmlMemoryErrorType</a></td>
        <td><span class="parametername">errorType</span></td>
        <td><p>Flag that specifies the type of the errors.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEccCounterType.html">nvmlEccCounterType</a></td>
        <td><span class="parametername">counterType</span></td>
        <td><p>Flag that specifies the counter-type of the errors.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span></td>
        <td><span class="parametername">eccCounts</span></td>
        <td><p>Reference in which to return the specified ECC errors</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a eccCounts has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a errorType or \a counterType is invalid, or \a eccCounts is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceClearEccErrorCounts()</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetUtilizationRates_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetUtilizationRates*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetUtilizationRates_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlUtilization__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetUtilizationRates(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlUtilization@)">nvmlDeviceGetUtilizationRates(nvmlDevice, ref nvmlUtilization)</h4>
  <div class="markdown level1 summary"><p>Retrieves the current utilization rates for the device's major subsystems.
For Fermi or newer fully supported devices.
See \ref nvmlUtilization for details on available utilization rates.
\note During driver initialization when ECC is enabled one can see high GPU and Memory Utilization readings.
This is caused by ECC Memory Scrubbing mechanism that is performed during driver initialization.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetUtilizationRates(nvmlDevice device, ref nvmlUtilization utilization)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlUtilization.html">nvmlUtilization</a></td>
        <td><span class="parametername">utilization</span></td>
        <td><p>Reference in which to return the utilization information</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a utilization has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a utilization is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  <span class="small pull-right mobile-hide">
    <span class="divider">|</span>
    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetUUID_ManagedCuda_Nvml_nvmlDevice_System_String__.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetUUID(ManagedCuda.Nvml.nvmlDevice%2CSystem.String%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
  </span>
  <span class="small pull-right mobile-hide">
    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L748">View Source</a>
  </span>
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetUUID_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetUUID*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetUUID_ManagedCuda_Nvml_nvmlDevice_System_String__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetUUID(ManagedCuda.Nvml.nvmlDevice,System.String@)">nvmlDeviceGetUUID(nvmlDevice, out String)</h4>
  <div class="markdown level1 summary"><p>Retrieves the globally unique immutable UUID associated with this device, as a 5 part hexadecimal string,
that augments the immutable, board serial identifier.
For all products.
The UUID is a globally unique identifier. It is the only available identifier for pre-Fermi-architecture products.
It does NOT correspond to any identifier printed on the board.  It will not exceed 80 characters in length
(including the NULL terminator).  See \ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetUUID(nvmlDevice device, out string uuid)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">uuid</span></td>
        <td><p>Reference in which to return the GPU UUID</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a uuid has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a uuid is NULL</li>
<li>\ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  <span class="small pull-right mobile-hide">
    <span class="divider">|</span>
    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetVbiosVersion_ManagedCuda_Nvml_nvmlDevice_System_String__.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetVbiosVersion(ManagedCuda.Nvml.nvmlDevice%2CSystem.String%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
  </span>
  <span class="small pull-right mobile-hide">
    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L1961">View Source</a>
  </span>
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetVbiosVersion_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetVbiosVersion*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetVbiosVersion_ManagedCuda_Nvml_nvmlDevice_System_String__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetVbiosVersion(ManagedCuda.Nvml.nvmlDevice,System.String@)">nvmlDeviceGetVbiosVersion(nvmlDevice, out String)</h4>
  <div class="markdown level1 summary"><p>Get VBIOS version of the device.
For all products.
The VBIOS version may change from time to time. It will not exceed 32 characters in length
(including the NULL terminator).  See \ref nvmlConstants::NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetVbiosVersion(nvmlDevice device, out string version)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">version</span></td>
        <td><p>Reference to which to return the VBIOS version</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a version has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a version is NULL</li>
<li>\ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetViolationStatus_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetViolationStatus*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceGetViolationStatus_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlPerfPolicyType_ManagedCuda_Nvml_nvmlViolationTime__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceGetViolationStatus(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlPerfPolicyType,ManagedCuda.Nvml.nvmlViolationTime@)">nvmlDeviceGetViolationStatus(nvmlDevice, nvmlPerfPolicyType, ref nvmlViolationTime)</h4>
  <div class="markdown level1 summary"><p>Gets the duration of time during which the device was throttled (lower than requested clocks) due to power
or thermal constraints.
The method is important to users who are tying to understand if their GPUs throttle at any point during their applications. The
difference in violation times at two different reference times gives the indication of GPU throttling event.
Violation for thermal capping is not supported at this time.</p>
<p>For Kepler or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceGetViolationStatus(nvmlDevice device, nvmlPerfPolicyType perfPolicyType, ref nvmlViolationTime violTime)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlPerfPolicyType.html">nvmlPerfPolicyType</a></td>
        <td><span class="parametername">perfPolicyType</span></td>
        <td><p>Represents Performance policy which can trigger GPU throttling</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlViolationTime.html">nvmlViolationTime</a></td>
        <td><span class="parametername">violTime</span></td>
        <td><p>Reference to which violation time related information is returned</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if violation time is successfully retrieved</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a perfPolicyType is invalid, or \a violTime is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceModifyDrainState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceModifyDrainState*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceModifyDrainState_System_UInt32_ManagedCuda_Nvml_nvmlEnableState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceModifyDrainState(System.UInt32,ManagedCuda.Nvml.nvmlEnableState)">nvmlDeviceModifyDrainState(UInt32, nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Modify the drain state of a GPU.  This method forces a GPU to no longer accept new incoming requests.
Any new NVML process will see a gap in the enumeration where this GPU should exist as any call to that
GPU outside of the drain state APIs will fail.
Must be called as administrator.
For Linux only.</p>
<p>For newer than Maxwell fully supported devices.
Some Kepler devices supported.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceModifyDrainState(uint nvmlIndex, nvmlEnableState newState)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">nvmlIndex</span></td>
        <td><p>The ID of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">newState</span></td>
        <td><p>The drain state that should be entered, see \ref nvmlEnableState</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if counters were successfully reset</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a nvmlIndex or \a newState is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceOnSameBoard_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceOnSameBoard*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceOnSameBoard_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlDevice_System_Int32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceOnSameBoard(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlDevice,System.Int32@)">nvmlDeviceOnSameBoard(nvmlDevice, nvmlDevice, ref Int32)</h4>
  <div class="markdown level1 summary"><p>Check if the GPU devices are on the same physical board.
For all fully supported products.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceOnSameBoard(nvmlDevice device1, nvmlDevice device2, ref int onSameBoard)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device1</span></td>
        <td><p>The first GPU device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device2</span></td>
        <td><p>The second GPU device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">onSameBoard</span></td>
        <td><p>Reference in which to return the status.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a onSameBoard has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a dev1 or \a dev2 are invalid or \a onSameBoard is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if this check is not supported by the device</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the either GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceQueryDrainState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceQueryDrainState*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceQueryDrainState_System_UInt32_ManagedCuda_Nvml_nvmlEnableState__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceQueryDrainState(System.UInt32,ManagedCuda.Nvml.nvmlEnableState@)">nvmlDeviceQueryDrainState(UInt32, ref nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Query the drain state of a GPU.  This method is used to check if a GPU is in a currently draining
state.
For Linux only.</p>
<p>For newer than Maxwell fully supported devices.
Some Kepler devices supported.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceQueryDrainState(uint nvmlIndex, ref nvmlEnableState currentState)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">nvmlIndex</span></td>
        <td><p>The ID of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">currentState</span></td>
        <td><p>The current drain state for this GPU, see \ref nvmlEnableState</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if counters were successfully reset</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a nvmlIndex or \a currentState is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceRegisterEvents_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceRegisterEvents*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceRegisterEvents_ManagedCuda_Nvml_nvmlDevice_System_UInt64_ManagedCuda_Nvml_nvmlEventSet_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceRegisterEvents(ManagedCuda.Nvml.nvmlDevice,System.UInt64,ManagedCuda.Nvml.nvmlEventSet)">nvmlDeviceRegisterEvents(nvmlDevice, UInt64, nvmlEventSet)</h4>
  <div class="markdown level1 summary"><p>Starts recording of events on a specified devices and add the events to specified \ref nvmlEventSet
For Fermi or newer fully supported devices.
Ecc events are available only on ECC enabled devices (see \ref nvmlDeviceGetTotalEccErrors)
Power capping events are available only on Power Management enabled devices (see \ref nvmlDeviceGetPowerManagementMode)
For Linux only.
\b IMPORTANT: Operations on \a set are not thread safe
This call starts recording of events on specific device.
All events that occurred before this call are not recorded.
Checking if some event occurred can be done with \ref nvmlEventSetWait
If function reports NVML_ERROR_UNKNOWN, event set is in undefined state and should be freed.
If function reports NVML_ERROR_NOT_SUPPORTED, event set can still be used. None of the requested eventTypes
are registered in that case.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceRegisterEvents(nvmlDevice device, ulong eventTypes, nvmlEventSet set)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt64</span></td>
        <td><span class="parametername">eventTypes</span></td>
        <td><p>Bitmask of \ref nvmlEventType to record</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEventSet.html">nvmlEventSet</a></td>
        <td><span class="parametername">set</span></td>
        <td><p>Set to which add new event types</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if the event has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a eventTypes is invalid or \a set is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if the platform does not support this feature or some of requested event types
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlEventType
@see nvmlDeviceGetSupportedEventTypes
@see nvmlEventSetWait
@see nvmlEventSetFree</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceRemoveGpu_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceRemoveGpu*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceRemoveGpu_System_UInt32_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceRemoveGpu(System.UInt32)">nvmlDeviceRemoveGpu(UInt32)</h4>
  <div class="markdown level1 summary"><p>This method will remove the specified GPU from the view of both NVML and the NVIDIA kernel driver
as long as no other processes are attached. If other processes are attached, this call will return
NVML_ERROR_IN_USE and the GPU will be returned to its original &quot;draining&quot; state. Note: the
only situation where a process can still be attached after nvmlDeviceModifyDrainState() is called
to initiate the draining state is if that process was using, and is still using, a GPU before the
call was made. Also note, persistence mode counts as an attachment to the GPU thus it must be disabled
prior to this call.
For long-running NVML processes please note that this will change the enumeration of current GPUs.
For example, if there are four GPUs present and GPU1 is removed, the new enumeration will be 0-2.
Also, device handles after the removed GPU will not be valid and must be re-established.
Must be run as administrator.
For Linux only.
For newer than Maxwell fully supported devices.
Some Kepler devices supported.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceRemoveGpu(uint nvmlIndex)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">nvmlIndex</span></td>
        <td><p>The ID of the target device</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if counters were successfully reset</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a nvmlIndex is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_IN_USE            if the device is still in use and cannot be removed</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceResetApplicationsClocks_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceResetApplicationsClocks*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceResetApplicationsClocks_ManagedCuda_Nvml_nvmlDevice_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceResetApplicationsClocks(ManagedCuda.Nvml.nvmlDevice)">nvmlDeviceResetApplicationsClocks(nvmlDevice)</h4>
  <div class="markdown level1 summary"><p>Resets the application clock to the default value
This is the applications clock that will be used after system reboot or driver reload.
Default value is constant, but the current value an be changed using \ref nvmlDeviceSetApplicationsClocks.
@see nvmlDeviceGetApplicationsClock
@see nvmlDeviceSetApplicationsClocks
For Fermi or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceResetApplicationsClocks(nvmlDevice device)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if new settings were successfully set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceResetNvLinkErrorCounters_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceResetNvLinkErrorCounters*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceResetNvLinkErrorCounters_ManagedCuda_Nvml_nvmlDevice_System_UInt32_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceResetNvLinkErrorCounters(ManagedCuda.Nvml.nvmlDevice,System.UInt32)">nvmlDeviceResetNvLinkErrorCounters(nvmlDevice, UInt32)</h4>
  <div class="markdown level1 summary"><p>Resets all error counters to zero
Please refer to \a nvmlNvLinkErrorCounter for the list of error counters that are reset
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceResetNvLinkErrorCounters(nvmlDevice device, uint link)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">link</span></td>
        <td><p>Specifies the NvLink link to be queried</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if the reset is successful</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceResetNvLinkUtilizationCounter_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceResetNvLinkUtilizationCounter*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceResetNvLinkUtilizationCounter_ManagedCuda_Nvml_nvmlDevice_System_UInt32_System_UInt32_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceResetNvLinkUtilizationCounter(ManagedCuda.Nvml.nvmlDevice,System.UInt32,System.UInt32)">nvmlDeviceResetNvLinkUtilizationCounter(nvmlDevice, UInt32, UInt32)</h4>
  <div class="markdown level1 summary"><p>Reset the NVLINK utilization counters
Both the receive and transmit counters are operated on by this function
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceResetNvLinkUtilizationCounter(nvmlDevice device, uint link, uint counter)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">link</span></td>
        <td><p>Specifies the NvLink link to be reset</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">counter</span></td>
        <td><p>Specifies the counter that should be reset (0 or 1)</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if counters were successfully reset</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a counter is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetAccountingMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetAccountingMode*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetAccountingMode_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetAccountingMode(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState)">nvmlDeviceSetAccountingMode(nvmlDevice, nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Enables or disables per process accounting.
For Kepler or newer fully supported devices.
Requires root/admin permissions.
@note This setting is not persistent and will default to disabled after driver unloads.
Enable persistence mode to be sure the setting doesn't switch off to disabled.</p>
<p>@note Enabling accounting mode has no negative impact on the GPU performance.
@note Disabling accounting clears all accounting pids information.
See \ref nvmlDeviceGetAccountingMode
See \ref nvmlDeviceGetAccountingStats
See \ref nvmlDeviceClearAccountingPids</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetAccountingMode(nvmlDevice device, nvmlEnableState mode)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">mode</span></td>
        <td><p>The target accounting mode</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if the new mode has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a mode are invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetAPIRestriction_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetAPIRestriction*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetAPIRestriction_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlRestrictedAPI_ManagedCuda_Nvml_nvmlEnableState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetAPIRestriction(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlRestrictedAPI,ManagedCuda.Nvml.nvmlEnableState)">nvmlDeviceSetAPIRestriction(nvmlDevice, nvmlRestrictedAPI, nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Changes the root/admin restructions on certain APIs. See \a nvmlRestrictedAPI for the list of supported APIs.
This method can be used by a root/admin user to give non-root/admin access to certain otherwise-restricted APIs.
The new setting lasts for the lifetime of the NVIDIA driver it is not persistent. See \a nvmlDeviceGetAPIRestriction
to query the current restriction settings.</p>
<p>For Kepler or newer fully supported devices.
Requires root/admin permissions.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetAPIRestriction(nvmlDevice device, nvmlRestrictedAPI apiType, nvmlEnableState isRestricted)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlRestrictedAPI.html">nvmlRestrictedAPI</a></td>
        <td><span class="parametername">apiType</span></td>
        <td><p>Target API type for this operation</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">isRestricted</span></td>
        <td><p>The target restriction</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a isRestricted has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a apiType incorrect
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support changing API restrictions or the device does not support
                                        the feature that api restrictions are being set for (E.G. Enabling/disabling auto 
                                        boosted clocks is not supported by the device)
- \ref NVML_ERROR_NO_PERMISSION     if the user doesn&amp;apos;t have permission to perform this operation
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlRestrictedAPI</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetApplicationsClocks_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetApplicationsClocks*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetApplicationsClocks_ManagedCuda_Nvml_nvmlDevice_System_UInt32_System_UInt32_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetApplicationsClocks(ManagedCuda.Nvml.nvmlDevice,System.UInt32,System.UInt32)">nvmlDeviceSetApplicationsClocks(nvmlDevice, UInt32, UInt32)</h4>
  <div class="markdown level1 summary"><p>Set clocks that applications will lock to.
Sets the clocks that compute and graphics applications will be running at.
e.g. CUDA driver requests these clocks during context creation which means this property
defines clocks at which CUDA applications will be running unless some overspec event
occurs (e.g. over power, over thermal or external HW brake).
Can be used as a setting to request constant performance.
For Kepler or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.
Requires root/admin permissions.
See \ref nvmlDeviceGetSupportedMemoryClocks and \ref nvmlDeviceGetSupportedGraphicsClocks
for details on how to list available clocks combinations.
After system reboot or driver reload applications clocks go back to their default value.
See \ref nvmlDeviceResetApplicationsClocks.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetApplicationsClocks(nvmlDevice device, uint memClockMHz, uint graphicsClockMHz)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">memClockMHz</span></td>
        <td><p>Requested memory clock in MHz</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">graphicsClockMHz</span></td>
        <td><p>Requested graphics clock in MHz</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if new settings were successfully set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a memClockMHz and \a graphicsClockMHz
is not a valid clock combination</li>
<li>\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetAutoBoostedClocksEnabled_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetAutoBoostedClocksEnabled*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetAutoBoostedClocksEnabled_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetAutoBoostedClocksEnabled(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState)">nvmlDeviceSetAutoBoostedClocksEnabled(nvmlDevice, nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Try to set the current state of auto boosted clocks on a device.
For Kepler or newer fully supported devices.
Auto boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
to maximize performance as thermal limits allow. Auto boosted clocks should be disabled if fixed clock
rates are desired.
Non-root users may use this API by default but can be restricted by root from using this API by calling
\ref nvmlDeviceSetAPIRestriction with apiType=NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS.
Note: Persistence Mode is required to modify current Auto boost settings, therefore, it must be enabled.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetAutoBoostedClocksEnabled(nvmlDevice device, nvmlEnableState enabled)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">enabled</span></td>
        <td><p>What state to try to set auto boosted clocks of the target device to</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 If the auto boosted clocks were successfully set to the state specified by \a enabled</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support auto boosted clocks</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetComputeMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetComputeMode*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetComputeMode_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlComputeMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetComputeMode(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlComputeMode)">nvmlDeviceSetComputeMode(nvmlDevice, nvmlComputeMode)</h4>
  <div class="markdown level1 summary"><p>Set the compute mode for the device.
For all products.
Requires root/admin permissions.
The compute mode determines whether a GPU can be used for compute operations and whether it can
be shared across contexts.
This operation takes effect immediately. Under Linux it is not persistent across reboots and
always resets to &quot;Default&quot;. Under windows it is persistent.
Under windows compute mode may only be set to DEFAULT when running in WDDM
See \ref nvmlComputeMode for details on available compute modes.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetComputeMode(nvmlDevice device, nvmlComputeMode mode)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlComputeMode.html">nvmlComputeMode</a></td>
        <td><span class="parametername">mode</span></td>
        <td><p>The target compute mode</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if the compute mode was set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is invalid
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_NO_PERMISSION     if the user doesn&amp;apos;t have permission to perform this operation
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetComputeMode()</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetCpuAffinity_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetCpuAffinity*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetCpuAffinity_ManagedCuda_Nvml_nvmlDevice_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetCpuAffinity(ManagedCuda.Nvml.nvmlDevice)">nvmlDeviceSetCpuAffinity(nvmlDevice)</h4>
  <div class="markdown level1 summary"><p>Sets the ideal affinity for the calling thread and device using the guidelines
given in nvmlDeviceGetCpuAffinity().  Note, this is a change as of version 8.0.<br>
Older versions set the affinity for a calling process and all children.
Currently supports up to 64 processors.
For Kepler or newer fully supported devices.
Supported on Linux only.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetCpuAffinity(nvmlDevice device)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if the calling process has been successfully bound</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetDefaultAutoBoostedClocksEnabled_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetDefaultAutoBoostedClocksEnabled*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetDefaultAutoBoostedClocksEnabled_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState_System_UInt32_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetDefaultAutoBoostedClocksEnabled(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState,System.UInt32)">nvmlDeviceSetDefaultAutoBoostedClocksEnabled(nvmlDevice, nvmlEnableState, UInt32)</h4>
  <div class="markdown level1 summary"><p>Try to set the default state of auto boosted clocks on a device. This is the default state that auto boosted clocks will
return to when no compute running processes (e.g. CUDA application which have an active context) are running
For Kepler or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.
Requires root/admin permissions.
Auto boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
to maximize performance as thermal limits allow. Auto boosted clocks should be disabled if fixed clock
rates are desired.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetDefaultAutoBoostedClocksEnabled(nvmlDevice device, nvmlEnableState enabled, uint flags)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">enabled</span></td>
        <td><p>What state to try to set default auto boosted clocks of the target device to</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">flags</span></td>
        <td><p>Flags that change the default behavior. Currently Unused.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 If the auto boosted clock's default state was successfully set to the state specified by \a enabled</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_NO_PERMISSION     If the calling user does not have permission to change auto boosted clock's default state.</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support auto boosted clocks</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetDriverModel_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetDriverModel*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetDriverModel_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlDriverModel_System_UInt32_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetDriverModel(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlDriverModel,System.UInt32)">nvmlDeviceSetDriverModel(nvmlDevice, nvmlDriverModel, UInt32)</h4>
  <div class="markdown level1 summary"><p>Set the driver model for the device.
For Fermi or newer fully supported devices.
For windows only.
Requires root/admin permissions.
On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached
to the device it must run in WDDM mode.<br>
It is possible to force the change to WDM (TCC) while the display is still attached with a force flag (nvmlFlagForce).
This should only be done if the host is subsequently powered down and the display is detached from the device
before the next reboot.
This operation takes effect after the next reboot.</p>
<p>Windows driver model may only be set to WDDM when running in DEFAULT compute mode.
Change driver model to WDDM is not supported when GPU doesn't support graphics acceleration or
will not support it after reboot. See \ref nvmlDeviceSetGpuOperationMode.
See \ref nvmlDriverModel for details on available driver models.
See \ref nvmlFlagDefault and \ref nvmlFlagForce</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetDriverModel(nvmlDevice device, nvmlDriverModel driverModel, uint flags)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDriverModel.html">nvmlDriverModel</a></td>
        <td><span class="parametername">driverModel</span></td>
        <td><p>The target driver model</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">flags</span></td>
        <td><p>Flags that change the default behavior</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if the driver model has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a driverModel is invalid
- \ref NVML_ERROR_NOT_SUPPORTED     if the platform is not windows or the device does not support this feature
- \ref NVML_ERROR_NO_PERMISSION     if the user doesn&amp;apos;t have permission to perform this operation
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetDriverModel()</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetEccMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetEccMode*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetEccMode_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetEccMode(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState)">nvmlDeviceSetEccMode(nvmlDevice, nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Set the ECC mode for the device.
For Kepler or newer fully supported devices.
Only applicable to devices with ECC.
Requires \a NVML_INFOROM_ECC version 1.0 or higher.
Requires root/admin permissions.
The ECC mode determines whether the GPU enables its ECC support.
This operation takes effect after the next reboot.
See \ref nvmlEnableState for details on available modes.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetEccMode(nvmlDevice device, nvmlEnableState ecc)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">ecc</span></td>
        <td><p>The target ECC mode</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if the ECC mode was set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a ecc is invalid
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_NO_PERMISSION     if the user doesn&amp;apos;t have permission to perform this operation
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetEccMode()</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetGpuOperationMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetGpuOperationMode*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetGpuOperationMode_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlGpuOperationMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetGpuOperationMode(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlGpuOperationMode)">nvmlDeviceSetGpuOperationMode(nvmlDevice, nvmlGpuOperationMode)</h4>
  <div class="markdown level1 summary"><p>Sets new GOM. See \a nvmlGpuOperationMode for details.
For GK110 M-class and X-class Tesla products from the Kepler family.
Modes \ref NVML_GOM_LOW_DP and \ref NVML_GOM_ALL_ON are supported on fully supported GeForce products.
Not supported on Quadro and Tesla C-class products.
Requires root/admin permissions.</p>
<p>Changing GOMs requires a reboot.
The reboot requirement might be removed in the future.
Compute only GOMs don't support graphics acceleration. Under windows switching to these GOMs when
pending driver model is WDDM is not supported. See \ref nvmlDeviceSetDriverModel.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetGpuOperationMode(nvmlDevice device, nvmlGpuOperationMode mode)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlGpuOperationMode.html">nvmlGpuOperationMode</a></td>
        <td><span class="parametername">mode</span></td>
        <td><p>Target GOM</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a mode has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode incorrect
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support GOM or specific mode
- \ref NVML_ERROR_NO_PERMISSION     if the user doesn&amp;apos;t have permission to perform this operation
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlGpuOperationMode
@see nvmlDeviceGetGpuOperationMode</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetNvLinkUtilizationControl_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetNvLinkUtilizationControl*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetNvLinkUtilizationControl_ManagedCuda_Nvml_nvmlDevice_System_UInt32_System_UInt32_ManagedCuda_Nvml_nvmlNvLinkUtilizationControl__System_UInt32_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetNvLinkUtilizationControl(ManagedCuda.Nvml.nvmlDevice,System.UInt32,System.UInt32,ManagedCuda.Nvml.nvmlNvLinkUtilizationControl@,System.UInt32)">nvmlDeviceSetNvLinkUtilizationControl(nvmlDevice, UInt32, UInt32, ref nvmlNvLinkUtilizationControl, UInt32)</h4>
  <div class="markdown level1 summary"><p>Set the NVLINK utilization counter control information for the specified counter, 0 or 1.
Please refer to \a nvmlNvLinkUtilizationControl for the structure definition.  Performs a reset
of the counters if the reset parameter is non-zero.
For newer than Maxwell fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetNvLinkUtilizationControl(nvmlDevice device, uint link, uint counter, ref nvmlNvLinkUtilizationControl control, uint reset)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">link</span></td>
        <td><p>Specifies the NvLink link to be queried</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">counter</span></td>
        <td><p>Specifies the counter that should be set (0 or 1).</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlNvLinkUtilizationControl.html">nvmlNvLinkUtilizationControl</a></td>
        <td><span class="parametername">control</span></td>
        <td><p>A reference to the \a nvmlNvLinkUtilizationControl to set</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">reset</span></td>
        <td><p>Resets the counters on set if non-zero</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if the control has been set successfully</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, \a link, or \a control is invalid</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetPersistenceMode_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetPersistenceMode*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetPersistenceMode_ManagedCuda_Nvml_nvmlDevice_ManagedCuda_Nvml_nvmlEnableState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetPersistenceMode(ManagedCuda.Nvml.nvmlDevice,ManagedCuda.Nvml.nvmlEnableState)">nvmlDeviceSetPersistenceMode(nvmlDevice, nvmlEnableState)</h4>
  <div class="markdown level1 summary"><p>Set the persistence mode for the device.
For all products.
For Linux only.
Requires root/admin permissions.
The persistence mode determines whether the GPU driver software is torn down after the last client
exits.
This operation takes effect immediately. It is not persistent across reboots. After each reboot the
persistence mode is reset to &quot;Disabled&quot;.
See \ref nvmlEnableState for available modes.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetPersistenceMode(nvmlDevice device, nvmlEnableState mode)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEnableState.html">nvmlEnableState</a></td>
        <td><span class="parametername">mode</span></td>
        <td><p>The target persistence mode</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if the persistence mode was set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is invalid
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_NO_PERMISSION     if the user doesn&amp;apos;t have permission to perform this operation
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetPersistenceMode()</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetPowerManagementLimit_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetPowerManagementLimit*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceSetPowerManagementLimit_ManagedCuda_Nvml_nvmlDevice_System_UInt32_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceSetPowerManagementLimit(ManagedCuda.Nvml.nvmlDevice,System.UInt32)">nvmlDeviceSetPowerManagementLimit(nvmlDevice, UInt32)</h4>
  <div class="markdown level1 summary"><p>Set new power limit of this device.</p>
<p>For Kepler or newer fully supported devices.
Requires root/admin permissions.
See \ref nvmlDeviceGetPowerManagementLimitConstraints to check the allowed ranges of values.
\note Limit is not persistent across reboots or driver unloads.
Enable persistent mode to prevent driver from unloading when no application is using the device.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceSetPowerManagementLimit(nvmlDevice device, uint limit)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">limit</span></td>
        <td><p>Power management limit in milliwatts to set</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a limit has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a defaultLimit is out of range
- \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
- \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceGetPowerManagementLimitConstraints
@see nvmlDeviceGetPowerManagementDefaultLimit</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceValidateInforom_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceValidateInforom*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlDeviceValidateInforom_ManagedCuda_Nvml_nvmlDevice_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlDeviceValidateInforom(ManagedCuda.Nvml.nvmlDevice)">nvmlDeviceValidateInforom(nvmlDevice)</h4>
  <div class="markdown level1 summary"><p>Reads the infoROM from the flash and verifies the checksums.
For all products with an inforom.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlDeviceValidateInforom(nvmlDevice device)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a></td>
        <td><span class="parametername">device</span></td>
        <td><p>The identifier of the target device</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if infoROM is not corrupted</li>
<li>\ref NVML_ERROR_CORRUPTED_INFOROM if the device's infoROM is corrupted</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature</li>
<li>\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  <span class="small pull-right mobile-hide">
    <span class="divider">|</span>
    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods_nvmlErrorString_ManagedCuda_Nvml_nvmlReturn_.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods.nvmlErrorString(ManagedCuda.Nvml.nvmlReturn)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
  </span>
  <span class="small pull-right mobile-hide">
    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L94">View Source</a>
  </span>
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlErrorString_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlErrorString*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlErrorString_ManagedCuda_Nvml_nvmlReturn_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlErrorString(ManagedCuda.Nvml.nvmlReturn)">nvmlErrorString(nvmlReturn)</h4>
  <div class="markdown level1 summary"><p>Helper method for converting NVML error codes into readable strings.
For all products.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static string nvmlErrorString(nvmlReturn result)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><span class="parametername">result</span></td>
        <td><p>NVML error code to convert</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><p>String representation of the error.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlEventSetCreate_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlEventSetCreate*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlEventSetCreate_ManagedCuda_Nvml_nvmlEventSet__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlEventSetCreate(ManagedCuda.Nvml.nvmlEventSet@)">nvmlEventSetCreate(ref nvmlEventSet)</h4>
  <div class="markdown level1 summary"><p>Create an empty set of events.
Event set should be freed by \ref nvmlEventSetFree
For Fermi or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlEventSetCreate(ref nvmlEventSet set)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEventSet.html">nvmlEventSet</a></td>
        <td><span class="parametername">set</span></td>
        <td><p>Reference in which to return the event handle</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if the event has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a set is NULL
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlEventSetFree</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlEventSetFree_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlEventSetFree*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlEventSetFree_ManagedCuda_Nvml_nvmlEventSet_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlEventSetFree(ManagedCuda.Nvml.nvmlEventSet)">nvmlEventSetFree(nvmlEventSet)</h4>
  <div class="markdown level1 summary"><p>Releases events in the set
For Fermi or newer fully supported devices.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlEventSetFree(nvmlEventSet set)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEventSet.html">nvmlEventSet</a></td>
        <td><span class="parametername">set</span></td>
        <td><p>Reference to events to be released</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if the event has been successfully released
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlDeviceRegisterEvents</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlEventSetWait_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlEventSetWait*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlEventSetWait_ManagedCuda_Nvml_nvmlEventSet_ManagedCuda_Nvml_nvmlEventData__System_UInt32_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlEventSetWait(ManagedCuda.Nvml.nvmlEventSet,ManagedCuda.Nvml.nvmlEventData@,System.UInt32)">nvmlEventSetWait(nvmlEventSet, ref nvmlEventData, UInt32)</h4>
  <div class="markdown level1 summary"><p>Waits on events and delivers events
For Fermi or newer fully supported devices.
If some events are ready to be delivered at the time of the call, function returns immediately.
If there are no events ready to be delivered, function sleeps till event arrives
but not longer than specified timeout. This function in certain conditions can return before
specified timeout passes (e.g. when interrupt arrives)</p>
<p>In case of xid error, the function returns the most recent xid error type seen by the system. If there are multiple
xid errors generated before nvmlEventSetWait is invoked then the last seen xid error type is returned for all
xid error events.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlEventSetWait(nvmlEventSet set, ref nvmlEventData data, uint timeoutms)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEventSet.html">nvmlEventSet</a></td>
        <td><span class="parametername">set</span></td>
        <td><p>Reference to set of events to wait on</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlEventData.html">nvmlEventData</a></td>
        <td><span class="parametername">data</span></td>
        <td><p>Reference in which to return event data</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">timeoutms</span></td>
        <td><p>Maximum amount of wait time in milliseconds for registered event</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if the data has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a data is NULL
- \ref NVML_ERRORIMEOUT           if no event arrived in specified timeout or interrupt arrived
- \ref NVML_ERROR_GPU_IS_LOST       if a GPU has fallen off the bus or is otherwise inaccessible
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlEventType
@see nvmlDeviceRegisterEvents</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlInit_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlInit*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlInit" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlInit">nvmlInit()</h4>
  <div class="markdown level1 summary"><p>Initialize NVML, but don't initialize any GPUs yet.
\note In NVML 5.319 new nvmlInit_v2 has replaced nvmlInit&quot;_v1&quot; (default in NVML 4.304 and older) that
did initialize all GPU devices in the system.</p>
<p>This allows NVML to communicate with a GPU
when other GPUs in the system are unstable or in a bad state.  When using this API, GPUs are
discovered and initialized in nvmlDeviceGetHandleBy* functions instead.</p>
<p>\note To contrast nvmlInit_v2 with nvmlInit&quot;_v1&quot;, NVML 4.304 nvmlInit&quot;_v1&quot; will fail when any detected GPU is in
a bad or unstable state.</p>
<p>For all products.
This method, should be called once before invoking any other methods in the library.
A reference count of the number of initializations is maintained.  Shutdown only occurs
when the reference count reaches zero.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlInit()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                   if NVML has been properly initialized</li>
<li>\ref NVML_ERROR_DRIVER_NOT_LOADED   if NVIDIA driver is not running</li>
<li>\ref NVML_ERROR_NO_PERMISSION       if NVML does not have permission to talk to the driver</li>
<li>\ref NVML_ERROR_UNKNOWN             on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlShutdown_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlShutdown*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlShutdown" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlShutdown">nvmlShutdown()</h4>
  <div class="markdown level1 summary"><p>Shut down NVML by releasing all GPU resources previously allocated with \ref nvmlInit().</p>
<p>For all products.
This method should be called after NVML work is done, once for each call to \ref nvmlInit()
A reference count of the number of initializations is maintained.  Shutdown only occurs
when the reference count reaches zero.  For backwards compatibility, no error is reported if
nvmlShutdown() is called more times than nvmlInit().</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlShutdown()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if NVML has been properly shut down</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  <span class="small pull-right mobile-hide">
    <span class="divider">|</span>
    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetDriverVersion_System_String__.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetDriverVersion(System.String%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
  </span>
  <span class="small pull-right mobile-hide">
    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L121">View Source</a>
  </span>
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetDriverVersion_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetDriverVersion*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetDriverVersion_System_String__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetDriverVersion(System.String@)">nvmlSystemGetDriverVersion(out String)</h4>
  <div class="markdown level1 summary"><p>Retrieves the version of the system's graphics driver.</p>
<p>For all products.
The version identifier is an alphanumeric string.  It will not exceed 80 characters in length
(including the NULL terminator).  See \ref nvmlConstants::NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlSystemGetDriverVersion(out string name)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a version has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL</li>
<li>\ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetDriverVersionInternal_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetDriverVersionInternal*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetDriverVersionInternal_System_Byte___System_UInt32_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetDriverVersionInternal(System.Byte[],System.UInt32)">nvmlSystemGetDriverVersionInternal(Byte[], UInt32)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlSystemGetDriverVersionInternal(byte[] version, uint length)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Byte</span>[]</td>
        <td><span class="parametername">version</span></td>
        <td></td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">length</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetHicVersion_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetHicVersion*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetHicVersion_System_UInt32__ManagedCuda_Nvml_nvmlHwbcEntry___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetHicVersion(System.UInt32@,ManagedCuda.Nvml.nvmlHwbcEntry[])">nvmlSystemGetHicVersion(ref UInt32, nvmlHwbcEntry[])</h4>
  <div class="markdown level1 summary"><p>Retrieves the IDs and firmware versions for any Host Interface Cards (HICs) in the system.</p>
<p>For S-class products.
The \a hwbcCount argument is expected to be set to the size of the input \a hwbcEntries array.
The HIC must be connected to an S-class system for it to be reported by this function.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlSystemGetHicVersion(ref uint hwbcCount, nvmlHwbcEntry[] hwbcEntries)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">hwbcCount</span></td>
        <td><p>Size of hwbcEntries array</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlHwbcEntry.html">nvmlHwbcEntry</a>[]</td>
        <td><span class="parametername">hwbcEntries</span></td>
        <td><p>Array holding information about hwbc</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a hwbcCount and \a hwbcEntries have been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if either \a hwbcCount or \a hwbcEntries is NULL</li>
<li>\ref NVML_ERROR_INSUFFICIENT_SIZE if \a hwbcCount indicates that the \a hwbcEntries array is too small</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  <span class="small pull-right mobile-hide">
    <span class="divider">|</span>
    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetNVMLVersion_System_String__.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetNVMLVersion(System.String%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
  </span>
  <span class="small pull-right mobile-hide">
    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L150">View Source</a>
  </span>
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetNVMLVersion_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetNVMLVersion*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetNVMLVersion_System_String__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetNVMLVersion(System.String@)">nvmlSystemGetNVMLVersion(out String)</h4>
  <div class="markdown level1 summary"><p>Retrieves the version of the NVML library.</p>
<p>For all products.
The version identifier is an alphanumeric string.  It will not exceed 80 characters in length
(including the NULL terminator).  See \ref nvmlConstants::NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlSystemGetNVMLVersion(out string name)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a version has been set</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL</li>
<li>\ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  <span class="small pull-right mobile-hide">
    <span class="divider">|</span>
    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetProcessName_System_UInt32_System_String__.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetProcessName(System.UInt32%2CSystem.String%40)%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">Improve this Doc</a>
  </span>
  <span class="small pull-right mobile-hide">
    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L183">View Source</a>
  </span>
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetProcessName_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetProcessName*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetProcessName_System_UInt32_System_String__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetProcessName(System.UInt32,System.String@)">nvmlSystemGetProcessName(UInt32, out String)</h4>
  <div class="markdown level1 summary"><p>Gets name of the process with provided process id
For all products.
Returned process name is cropped to provided length.
name string is encoded in ANSI.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlSystemGetProcessName(uint pid, out string name)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">pid</span></td>
        <td><p>The identifier of the process</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.String</span></td>
        <td><span class="parametername">name</span></td>
        <td><p>Reference in which to return the process name</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a name has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a name is NULL or \a length is 0.</li>
<li>\ref NVML_ERROR_NOT_FOUND         if process doesn't exists</li>
<li>\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetTopologyGpuSet_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetTopologyGpuSet*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlSystemGetTopologyGpuSet_System_UInt32_System_UInt32__ManagedCuda_Nvml_nvmlDevice___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlSystemGetTopologyGpuSet(System.UInt32,System.UInt32@,ManagedCuda.Nvml.nvmlDevice[])">nvmlSystemGetTopologyGpuSet(UInt32, ref UInt32, nvmlDevice[])</h4>
  <div class="markdown level1 summary"><p>Retrieve the set of GPUs that have a CPU affinity with the given CPU number
For all products.
Supported on Linux only.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlSystemGetTopologyGpuSet(uint cpuNumber, ref uint count, nvmlDevice[] deviceArray)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">cpuNumber</span></td>
        <td><p>The CPU number</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>When zero, is set to the number of matching GPUs such that \a deviceArray</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a>[]</td>
        <td><span class="parametername">deviceArray</span></td>
        <td><p>An array of device handles for GPUs found with affinity to \a cpuNumber</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a deviceArray or \a count (if initially zero) has been set</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a cpuNumber, or \a count is invalid, or \a deviceArray is NULL with a non-zero \a count</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature</li>
<li>\ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetCount_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetCount*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetCount_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetCount(System.UInt32@)">nvmlUnitGetCount(ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the number of units in the system.
For S-class products.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlUnitGetCount(ref uint unitCount)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">unitCount</span></td>
        <td><p>Reference in which to return the number of units</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a unitCount has been set</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a unitCount is NULL</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetDevices_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetDevices*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetDevices_ManagedCuda_Nvml_nvmlUnit_System_UInt32__ManagedCuda_Nvml_nvmlDevice___" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetDevices(ManagedCuda.Nvml.nvmlUnit,System.UInt32@,ManagedCuda.Nvml.nvmlDevice[])">nvmlUnitGetDevices(nvmlUnit, ref UInt32, nvmlDevice[])</h4>
  <div class="markdown level1 summary"><p>Retrieves the set of GPU devices that are attached to the specified unit.
For S-class products.
The \a deviceCount argument is expected to be set to the size of the input \a devices array.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlUnitGetDevices(nvmlUnit unit, ref uint deviceCount, nvmlDevice[] devices)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlUnit.html">nvmlUnit</a></td>
        <td><span class="parametername">unit</span></td>
        <td><p>The identifier of the target unit</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">deviceCount</span></td>
        <td><p>Reference in which to provide the \a devices array size, and</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlDevice.html">nvmlDevice</a>[]</td>
        <td><span class="parametername">devices</span></td>
        <td><p>Reference in which to return the references to the attached GPU devices</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a deviceCount and \a devices have been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INSUFFICIENT_SIZE if \a deviceCount indicates that the \a devices array is too small</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a unit is invalid, either of \a deviceCount or \a devices is NULL</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetFanSpeedInfo_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetFanSpeedInfo*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetFanSpeedInfo_ManagedCuda_Nvml_nvmlUnit_ManagedCuda_Nvml_nvmlUnitFanSpeeds__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetFanSpeedInfo(ManagedCuda.Nvml.nvmlUnit,ManagedCuda.Nvml.nvmlUnitFanSpeeds@)">nvmlUnitGetFanSpeedInfo(nvmlUnit, ref nvmlUnitFanSpeeds)</h4>
  <div class="markdown level1 summary"><p>Retrieves the fan speed readings for the unit.
For S-class products.
See \ref nvmlUnitFanSpeeds for details on available fan speed info.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlUnitGetFanSpeedInfo(nvmlUnit unit, ref nvmlUnitFanSpeeds fanSpeeds)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlUnit.html">nvmlUnit</a></td>
        <td><span class="parametername">unit</span></td>
        <td><p>The identifier of the target unit</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlUnitFanSpeeds.html">nvmlUnitFanSpeeds</a></td>
        <td><span class="parametername">fanSpeeds</span></td>
        <td><p>Reference in which to return the fan speed information</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a fanSpeeds has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a unit is invalid or \a fanSpeeds is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetHandleByIndex_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetHandleByIndex*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetHandleByIndex_System_UInt32_ManagedCuda_Nvml_nvmlUnit__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetHandleByIndex(System.UInt32,ManagedCuda.Nvml.nvmlUnit@)">nvmlUnitGetHandleByIndex(UInt32, ref nvmlUnit)</h4>
  <div class="markdown level1 summary"></div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlUnitGetHandleByIndex(uint index, ref nvmlUnit unit)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">index</span></td>
        <td></td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlUnit.html">nvmlUnit</a></td>
        <td><span class="parametername">unit</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetLedState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetLedState*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetLedState_ManagedCuda_Nvml_nvmlUnit_ManagedCuda_Nvml_nvmlLedState__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetLedState(ManagedCuda.Nvml.nvmlUnit,ManagedCuda.Nvml.nvmlLedState@)">nvmlUnitGetLedState(nvmlUnit, ref nvmlLedState)</h4>
  <div class="markdown level1 summary"><p>Retrieves the LED state associated with this unit.
For S-class products.
See \ref nvmlLedState for details on allowed states.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlUnitGetLedState(nvmlUnit unit, ref nvmlLedState state)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlUnit.html">nvmlUnit</a></td>
        <td><span class="parametername">unit</span></td>
        <td><p>The identifier of the target unit</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlLedState.html">nvmlLedState</a></td>
        <td><span class="parametername">state</span></td>
        <td><p>Reference in which to return the current LED state</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if \a state has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a unit is invalid or \a state is NULL
- \ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlUnitSetLedState()</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetPsuInfo_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetPsuInfo*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetPsuInfo_ManagedCuda_Nvml_nvmlUnit_ManagedCuda_Nvml_nvmlPSUInfo__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetPsuInfo(ManagedCuda.Nvml.nvmlUnit,ManagedCuda.Nvml.nvmlPSUInfo@)">nvmlUnitGetPsuInfo(nvmlUnit, ref nvmlPSUInfo)</h4>
  <div class="markdown level1 summary"><p>Retrieves the PSU stats for the unit.
For S-class products.
See \ref nvmlPSUInfo for details on available PSU info.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlUnitGetPsuInfo(nvmlUnit unit, ref nvmlPSUInfo psu)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlUnit.html">nvmlUnit</a></td>
        <td><span class="parametername">unit</span></td>
        <td><p>The identifier of the target unit</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlPSUInfo.html">nvmlPSUInfo</a></td>
        <td><span class="parametername">psu</span></td>
        <td><p>Reference in which to return the PSU information</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a psu has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a unit is invalid or \a psu is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetTemperature_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetTemperature*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetTemperature_ManagedCuda_Nvml_nvmlUnit_System_UInt32_System_UInt32__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetTemperature(ManagedCuda.Nvml.nvmlUnit,System.UInt32,System.UInt32@)">nvmlUnitGetTemperature(nvmlUnit, UInt32, ref UInt32)</h4>
  <div class="markdown level1 summary"><p>Retrieves the temperature readings for the unit, in degrees C.
For S-class products.
Depending on the product, readings may be available for intake (type=0),
exhaust (type=1) and board (type=2).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlUnitGetTemperature(nvmlUnit unit, uint type, ref uint temp)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlUnit.html">nvmlUnit</a></td>
        <td><span class="parametername">unit</span></td>
        <td><p>The identifier of the target unit</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">type</span></td>
        <td><p>The type of reading to take</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.UInt32</span></td>
        <td><span class="parametername">temp</span></td>
        <td><p>Reference in which to return the intake temperature</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a temp has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a unit or \a type is invalid or \a temp is NULL</li>
<li>\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product</li>
<li>\ref NVML_ERROR_UNKNOWN           on any unexpected error</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetUnitInfo_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetUnitInfo*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitGetUnitInfo_ManagedCuda_Nvml_nvmlUnit_ManagedCuda_Nvml_nvmlUnitInfo__" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitGetUnitInfo(ManagedCuda.Nvml.nvmlUnit,ManagedCuda.Nvml.nvmlUnitInfo@)">nvmlUnitGetUnitInfo(nvmlUnit, ref nvmlUnitInfo)</h4>
  <div class="markdown level1 summary"><p>Retrieves the static information associated with a unit.
For S-class products.
See \ref nvmlUnitInfo for details on available unit info.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlUnitGetUnitInfo(nvmlUnit unit, ref nvmlUnitInfo info)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlUnit.html">nvmlUnit</a></td>
        <td><span class="parametername">unit</span></td>
        <td><p>The identifier of the target unit</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlUnitInfo.html">nvmlUnitInfo</a></td>
        <td><span class="parametername">info</span></td>
        <td><p>Reference in which to return the unit information</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><ul>
<li>\ref NVML_SUCCESS                 if \a info has been populated</li>
<li>\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized</li>
<li>\ref NVML_ERROR_INVALID_ARGUMENT  if \a unit is invalid or \a info is NULL</li>
</ul>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitSetLedState_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitSetLedState*"></a>
  <h4 id="ManagedCuda_Nvml_NvmlNativeMethods_nvmlUnitSetLedState_ManagedCuda_Nvml_nvmlUnit_ManagedCuda_Nvml_nvmlLedColor_" data-uid="ManagedCuda.Nvml.NvmlNativeMethods.nvmlUnitSetLedState(ManagedCuda.Nvml.nvmlUnit,ManagedCuda.Nvml.nvmlLedColor)">nvmlUnitSetLedState(nvmlUnit, nvmlLedColor)</h4>
  <div class="markdown level1 summary"><p>Set the LED state for the unit. The LED can be either green (0) or amber (1).
For S-class products.
Requires root/admin permissions.
This operation takes effect immediately.</p>
<p><strong>Current S-Class products don't provide unique LEDs for each unit. As such, both front
and back LEDs will be toggled in unison regardless of which unit is specified with this command.</strong>
See \ref nvmlLedColor for available colors.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static nvmlReturn nvmlUnitSetLedState(nvmlUnit unit, nvmlLedColor color)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlUnit.html">nvmlUnit</a></td>
        <td><span class="parametername">unit</span></td>
        <td><p>The identifier of the target unit</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlLedColor.html">nvmlLedColor</a></td>
        <td><span class="parametername">color</span></td>
        <td><p>The target LED color</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="ManagedCuda.Nvml.nvmlReturn.html">nvmlReturn</a></td>
        <td><pre><code>- \ref NVML_SUCCESS                 if the LED color has been set
- \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
- \ref NVML_ERROR_INVALID_ARGUMENT  if \a unit or \a color is invalid
- \ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product
- \ref NVML_ERROR_NO_PERMISSION     if the user doesn&amp;apos;t have permission to perform this operation
- \ref NVML_ERROR_UNKNOWN           on any unexpected error
</code></pre>
<p>@see nvmlUnitGetLedState()</p>
</td>
      </tr>
    </tbody>
  </table>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/surban/managedCuda/new/51b251a86e6faf81b9e721b916b962d3718cece8/apiSpec/new?filename=ManagedCuda_Nvml_NvmlNativeMethods.md&amp;value=---%0Auid%3A%20ManagedCuda.Nvml.NvmlNativeMethods%0Asummary%3A%20'*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax'%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A" class="contribution-link">Improve this Doc</a>
                  </li>
                  <li>
                    <a href="https://github.com/surban/managedCuda/blob/51b251a86e6faf81b9e721b916b962d3718cece8/Nvml/NvmlNativeMethods.cs/#L31" class="contribution-link">View Source</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
